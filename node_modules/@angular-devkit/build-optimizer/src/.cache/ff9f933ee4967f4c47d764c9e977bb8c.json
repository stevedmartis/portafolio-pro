{"remainingRequest":"C:\\Users\\dmartinez\\Documents\\demaro-recuperado\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--8-1!C:\\Users\\dmartinez\\Documents\\demaro-recuperado\\node_modules\\angular-bootstrap-md\\esm5\\angular-bootstrap-md.es5.js","dependencies":[{"path":"C:\\Users\\dmartinez\\Documents\\demaro-recuperado\\node_modules\\angular-bootstrap-md\\esm5\\angular-bootstrap-md.es5.js","mtime":499162500000},{"path":"C:\\Users\\dmartinez\\Documents\\demaro-recuperado\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1547479999106},{"path":"C:\\Users\\dmartinez\\Documents\\demaro-recuperado\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1525297313000}],"contextDependencies":[],"result":["import { ApplicationRef, Attribute, ChangeDetectionStrategy, ChangeDetectorRef, Component, ComponentFactoryResolver, ContentChildren, Directive, ElementRef, EventEmitter, HostBinding, HostListener, Inject, Injectable, Injector, Input, NO_ERRORS_SCHEMA, NgModule, NgZone, Output, PLATFORM_ID, ReflectiveInjector, Renderer2, TemplateRef, ViewChild, ViewContainerRef, ViewEncapsulation, defineInjectable, forwardRef } from '@angular/core';\nimport { CommonModule, isPlatformBrowser } from '@angular/common';\nimport { FormsModule, NG_VALIDATORS, NG_VALUE_ACCESSOR } from '@angular/forms';\nimport { Observable, Subject } from 'rxjs';\nimport { RouterLinkWithHref } from '@angular/router';\nimport * as Chart from 'chart.js';\nimport { animate, state, style, transition, trigger } from '@angular/animations';\nimport { __decorate, __metadata } from 'tslib';\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\nvar MdbCardFooterComponent = /*@__PURE__*/ (function () {\n    /**\n     * @param {?} _el\n     * @param {?} _r\n     */\n    function MdbCardFooterComponent(_el, _r) {\n        this._el = _el;\n        this._r = _r;\n    }\n    /**\n     * @return {?}\n     */\n    MdbCardFooterComponent.prototype.ngOnInit = function () {\n        var _this = this;\n        // this._r.addClass(this._el.nativeElement, 'card-footer');\n        if (this.class) {\n            this.class.split(' ').forEach(function (element) {\n                _this._r.addClass(_this._el.nativeElement, element);\n            });\n        }\n    };\n    return MdbCardFooterComponent;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\nvar MdbCardTitleComponent = /*@__PURE__*/ (function () {\n    /**\n     * @param {?} _el\n     * @param {?} _r\n     */\n    function MdbCardTitleComponent(_el, _r) {\n        this._el = _el;\n        this._r = _r;\n    }\n    /**\n     * @return {?}\n     */\n    MdbCardTitleComponent.prototype.ngOnInit = function () {\n        this._r.addClass(this._el.nativeElement, 'card-title');\n    };\n    return MdbCardTitleComponent;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\nvar MdbCardTextComponent = /*@__PURE__*/ (function () {\n    function MdbCardTextComponent() {\n    }\n    return MdbCardTextComponent;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\nvar MdbCardBodyComponent = /*@__PURE__*/ (function () {\n    /**\n     * @param {?} _el\n     * @param {?} _r\n     */\n    function MdbCardBodyComponent(_el, _r) {\n        this._el = _el;\n        this._r = _r;\n    }\n    Object.defineProperty(MdbCardBodyComponent.prototype, \"cascade\", {\n        /**\n         * @param {?} cascade\n         * @return {?}\n         */\n        set: function (cascade) {\n            if (cascade) {\n                this._r.addClass(this._el.nativeElement, 'card-body-cascade');\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    MdbCardBodyComponent.prototype.ngOnInit = function () {\n        var _this = this;\n        this._r.addClass(this._el.nativeElement, 'card-body');\n        if (this.class) {\n            this.class.split(' ').forEach(function (element) {\n                _this._r.addClass(_this._el.nativeElement, element);\n            });\n        }\n    };\n    return MdbCardBodyComponent;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\nvar MdbCardComponent = /*@__PURE__*/ (function () {\n    /**\n     * @param {?} _el\n     * @param {?} _r\n     */\n    function MdbCardComponent(_el, _r) {\n        this._el = _el;\n        this._r = _r;\n    }\n    Object.defineProperty(MdbCardComponent.prototype, \"narrower\", {\n        /**\n         * @param {?} narrower\n         * @return {?}\n         */\n        set: function (narrower) {\n            if (narrower) {\n                this._r.addClass(this._el.nativeElement, 'narrower');\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MdbCardComponent.prototype, \"reverse\", {\n        /**\n         * @param {?} reverse\n         * @return {?}\n         */\n        set: function (reverse) {\n            if (reverse) {\n                this._r.addClass(this._el.nativeElement, 'reverse');\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MdbCardComponent.prototype, \"dark\", {\n        /**\n         * @param {?} dark\n         * @return {?}\n         */\n        set: function (dark) {\n            if (dark) {\n                this._r.addClass(this._el.nativeElement, 'card-dark');\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    MdbCardComponent.prototype.ngOnInit = function () {\n        var _this = this;\n        this._r.addClass(this._el.nativeElement, 'card');\n        if (this.cascade) {\n            this._r.addClass(this._el.nativeElement, 'card-cascade');\n        }\n        if (this.wider) {\n            this._r.addClass(this._el.nativeElement, 'wider');\n        }\n        if (this.narrower) {\n            this._r.addClass(this._el.nativeElement, 'narrower');\n        }\n        if (this.class) {\n            this.class.split(' ').forEach(function (element) {\n                _this._r.addClass(_this._el.nativeElement, element);\n            });\n        }\n    };\n    return MdbCardComponent;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\nvar MdbCardImageComponent = /*@__PURE__*/ (function () {\n    function MdbCardImageComponent() {\n    }\n    return MdbCardImageComponent;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\nvar MdbCardHeaderComponent = /*@__PURE__*/ (function () {\n    /**\n     * @param {?} _el\n     * @param {?} _r\n     */\n    function MdbCardHeaderComponent(_el, _r) {\n        this._el = _el;\n        this._r = _r;\n    }\n    /**\n     * @return {?}\n     */\n    MdbCardHeaderComponent.prototype.ngOnInit = function () {\n        var _this = this;\n        this._r.addClass(this._el.nativeElement, 'card-header');\n        if (this.class) {\n            this.class.split(' ').forEach(function (element) {\n                _this._r.addClass(_this._el.nativeElement, element);\n            });\n        }\n    };\n    return MdbCardHeaderComponent;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\nvar CardsFreeModule = /*@__PURE__*/ (function () {\n    function CardsFreeModule() {\n    }\n    /**\n     * @return {?}\n     */\n    CardsFreeModule.forRoot = function () {\n        return { ngModule: CardsFreeModule, providers: [] };\n    };\n    return CardsFreeModule;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\nvar MdbBtnDirective = /*@__PURE__*/ (function () {\n    /**\n     * @param {?} el\n     * @param {?} renderer\n     */\n    function MdbBtnDirective(el, renderer) {\n        this.el = el;\n        this.renderer = renderer;\n        this.color = '';\n        this.rounded = false;\n        this.gradient = '';\n        this.outline = false;\n        this.flat = false;\n        this.size = '';\n        this.block = false;\n        this.floating = false;\n    }\n    /**\n     * @return {?}\n     */\n    MdbBtnDirective.prototype.ngOnInit = function () {\n        /** @type {?} */\n        var colorClass = 'btn-' + this.color;\n        /** @type {?} */\n        var gradientClass = this.gradient + '-gradient';\n        /** @type {?} */\n        var outlineClass = 'btn-outline-' + this.color;\n        /** @type {?} */\n        var flatClass = 'btn-flat';\n        /** @type {?} */\n        var roundedClass = 'btn-rounded';\n        /** @type {?} */\n        var sizeClass = 'btn-' + this.size;\n        /** @type {?} */\n        var blockClass = 'btn-block';\n        /** @type {?} */\n        var floatingClass = 'btn-floating';\n        this.renderer.addClass(this.el.nativeElement, 'btn');\n        if (this.color !== '') {\n            this.renderer.addClass(this.el.nativeElement, colorClass);\n        }\n        if (this.rounded) {\n            this.renderer.addClass(this.el.nativeElement, roundedClass);\n        }\n        if (this.gradient) {\n            if (this.color !== '') {\n                this.renderer.removeClass(this.el.nativeElement, colorClass);\n            }\n            this.renderer.addClass(this.el.nativeElement, gradientClass);\n        }\n        if (this.outline) {\n            this.renderer.removeClass(this.el.nativeElement, colorClass);\n            this.renderer.addClass(this.el.nativeElement, outlineClass);\n        }\n        if (this.flat) {\n            if (this.color) {\n                this.renderer.removeClass(this.el.nativeElement, colorClass);\n            }\n            if (this.gradient) {\n                this.renderer.removeClass(this.el.nativeElement, gradientClass);\n            }\n            if (this.outline) {\n                this.renderer.removeClass(this.el.nativeElement, outlineClass);\n            }\n            if (this.rounded) {\n                this.renderer.removeClass(this.el.nativeElement, roundedClass);\n            }\n            this.renderer.addClass(this.el.nativeElement, flatClass);\n        }\n        if (this.size) {\n            this.renderer.addClass(this.el.nativeElement, sizeClass);\n        }\n        if (this.block) {\n            this.renderer.addClass(this.el.nativeElement, blockClass);\n        }\n        if (this.floating) {\n            this.renderer.removeClass(this.el.nativeElement, 'btn');\n            this.renderer.addClass(this.el.nativeElement, floatingClass);\n        }\n    };\n    return MdbBtnDirective;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/** @type {?} */\nvar CHECKBOX_CONTROL_VALUE_ACCESSOR = {\n    provide: NG_VALUE_ACCESSOR,\n    useExisting: forwardRef(function () { return ButtonCheckboxDirective; }),\n    multi: true\n};\n/**\n * Add checkbox functionality to any element\n */\nvar ButtonCheckboxDirective = /*@__PURE__*/ (function () {\n    function ButtonCheckboxDirective() {\n        /**\n         * Truthy value, will be set to ngModel\n         */\n        this.btnCheckboxTrue = true;\n        /**\n         * Falsy value, will be set to ngModel\n         */\n        this.btnCheckboxFalse = false;\n        this.state = false;\n        this.onChange = Function.prototype;\n        this.onTouched = Function.prototype;\n    }\n    /**\n     * @return {?}\n     */\n    ButtonCheckboxDirective.prototype.onClick = function () {\n        if (this.isDisabled) {\n            return;\n        }\n        this.toggle(!this.state);\n        this.onChange(this.value);\n    };\n    /**\n     * @return {?}\n     */\n    ButtonCheckboxDirective.prototype.ngOnInit = function () {\n        this.toggle(this.trueValue === this.value);\n    };\n    Object.defineProperty(ButtonCheckboxDirective.prototype, \"trueValue\", {\n        /**\n         * @return {?}\n         */\n        get: function () {\n            return typeof this.btnCheckboxTrue !== 'undefined'\n                ? this.btnCheckboxTrue\n                : true;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ButtonCheckboxDirective.prototype, \"falseValue\", {\n        /**\n         * @return {?}\n         */\n        get: function () {\n            return typeof this.btnCheckboxFalse !== 'undefined'\n                ? this.btnCheckboxFalse\n                : false;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @param {?} state\n     * @return {?}\n     */\n    ButtonCheckboxDirective.prototype.toggle = function (state$$1) {\n        this.state = state$$1;\n        this.value = this.state ? this.trueValue : this.falseValue;\n    };\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    ButtonCheckboxDirective.prototype.writeValue = function (value) {\n        this.state = this.trueValue === value;\n        this.value = value ? this.trueValue : this.falseValue;\n    };\n    /**\n     * @param {?} isDisabled\n     * @return {?}\n     */\n    ButtonCheckboxDirective.prototype.setDisabledState = function (isDisabled) {\n        this.isDisabled = isDisabled;\n    };\n    /**\n     * @param {?} fn\n     * @return {?}\n     */\n    ButtonCheckboxDirective.prototype.registerOnChange = function (fn) {\n        this.onChange = fn;\n    };\n    /**\n     * @param {?} fn\n     * @return {?}\n     */\n    ButtonCheckboxDirective.prototype.registerOnTouched = function (fn) {\n        this.onTouched = fn;\n    };\n    return ButtonCheckboxDirective;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/** @type {?} */\nvar RADIO_CONTROL_VALUE_ACCESSOR = {\n    provide: NG_VALUE_ACCESSOR,\n    useExisting: forwardRef(function () { return ButtonRadioDirective; }),\n    multi: true\n};\n/**\n * Create radio buttons or groups of buttons.\n * A value of a selected button is bound to a variable specified via ngModel.\n */\nvar ButtonRadioDirective = /*@__PURE__*/ (function () {\n    /**\n     * @param {?} el\n     * @param {?} renderer\n     */\n    function ButtonRadioDirective(el, renderer) {\n        this.renderer = renderer;\n        this.onChange = Function.prototype;\n        this.onTouched = Function.prototype;\n        this.radioElementsArray = [];\n        this.el = el;\n    }\n    Object.defineProperty(ButtonRadioDirective.prototype, \"isActive\", {\n        /**\n         * @return {?}\n         */\n        get: function () {\n            return this.mdbRadio === this.value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @param {?=} event\n     * @return {?}\n     */\n    ButtonRadioDirective.prototype.onClick = function (event) {\n        var _this = this;\n        try {\n            this.el.nativeElement.parentElement.childNodes.forEach(function (element) {\n                _this.radioElementsArray.push(element);\n            });\n            this.radioElementsArray.forEach(function (element) {\n                _this.renderer.removeClass(element, 'active');\n            });\n            this.renderer.addClass(event.target, 'active');\n        }\n        catch (error) {\n        }\n        if (this.el.nativeElement.attributes.disabled) {\n            return;\n        }\n        if (this.uncheckable && this.mdbRadio === this.value) {\n            this.value = undefined;\n        }\n        else {\n            this.value = this.mdbRadio;\n        }\n        this.onTouched();\n        this.onChange(this.value);\n    };\n    /**\n     * @return {?}\n     */\n    ButtonRadioDirective.prototype.ngOnInit = function () {\n        this.uncheckable = typeof this.uncheckable !== 'undefined';\n    };\n    /**\n     * @return {?}\n     */\n    ButtonRadioDirective.prototype.onBlur = function () {\n        this.onTouched();\n    };\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    ButtonRadioDirective.prototype.writeValue = function (value) {\n        this.value = value;\n    };\n    /**\n     * @param {?} fn\n     * @return {?}\n     */\n    ButtonRadioDirective.prototype.registerOnChange = function (fn) {\n        this.onChange = fn;\n    };\n    /**\n     * @param {?} fn\n     * @return {?}\n     */\n    ButtonRadioDirective.prototype.registerOnTouched = function (fn) {\n        this.onTouched = fn;\n    };\n    return ButtonRadioDirective;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\nvar ButtonsModule = /*@__PURE__*/ (function () {\n    function ButtonsModule() {\n    }\n    /**\n     * @return {?}\n     */\n    ButtonsModule.forRoot = function () {\n        return { ngModule: ButtonsModule, providers: [] };\n    };\n    return ButtonsModule;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\nvar RippleDirective = /*@__PURE__*/ (function () {\n    /**\n     * @param {?} el\n     */\n    function RippleDirective(el) {\n        this.el = el;\n    }\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n    RippleDirective.prototype.click = function (event) {\n        // event.stopPropagation();\n        if (!this.el.nativeElement.classList.contains('disabled')) {\n            /** @type {?} */\n            var button = this.el.nativeElement;\n            if (!button.classList.contains('waves-effect')) {\n                button.className += ' waves-effect';\n            }\n            /** @type {?} */\n            var xPos = event.clientX - button.getBoundingClientRect().left;\n            /** @type {?} */\n            var yPos = event.clientY - button.getBoundingClientRect().top;\n            /** @type {?} */\n            var tmp = document.createElement('div');\n            tmp.className += 'waves-ripple waves-rippling';\n            /** @type {?} */\n            var ripple = button.appendChild(tmp);\n            /** @type {?} */\n            var top = yPos + 'px';\n            /** @type {?} */\n            var left = xPos + 'px';\n            tmp.style.top = top;\n            tmp.style.left = left;\n            /** @type {?} */\n            var scale = 'scale(' + ((button.clientWidth / 100) * 3) + ') translate(0,0)';\n            tmp.style.webkitTransform = scale;\n            tmp.style.transform = scale;\n            tmp.style.opacity = '1';\n            /** @type {?} */\n            var duration = 750;\n            tmp.style.webkitTransitionDuration = duration + 'ms';\n            tmp.style.transitionDuration = duration + 'ms';\n            this.removeRipple(button, ripple);\n        }\n    };\n    /**\n     * @param {?} button\n     * @param {?} ripple\n     * @return {?}\n     */\n    RippleDirective.prototype.removeRipple = function (button, ripple) {\n        ripple.classList.remove('waves-rippling');\n        setTimeout(function () {\n            ripple.style.opacity = '0';\n            setTimeout(function () {\n                button.removeChild(ripple);\n            }, 750);\n        }, 200);\n    };\n    return RippleDirective;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\nvar RippleModule = /*@__PURE__*/ (function () {\n    function RippleModule() {\n    }\n    /**\n     * @return {?}\n     */\n    RippleModule.forRoot = function () {\n        return { ngModule: RippleModule, providers: [] };\n    };\n    return RippleModule;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\nvar MdbInputDirective = /*@__PURE__*/ (function () {\n    /**\n     * @param {?} _elRef\n     * @param {?} _renderer\n     * @param {?} platformId\n     */\n    function MdbInputDirective(_elRef, _renderer, platformId) {\n        this._elRef = _elRef;\n        this._renderer = _renderer;\n        this.el = null;\n        this.elLabel = null;\n        this.elIcon = null;\n        this.element = null;\n        this.mdbValidate = true;\n        this.validateSuccess = true;\n        this.validateError = true;\n        this.focusCheckbox = true;\n        this.focusRadio = true;\n        this.isBrowser = false;\n        this.isClicked = false;\n        this.el = _elRef;\n        this.isBrowser = isPlatformBrowser(platformId);\n    }\n    /**\n     * @return {?}\n     */\n    MdbInputDirective.prototype.onfocus = function () {\n        try {\n            this._renderer.addClass(this.elLabel, 'active');\n            this.isClicked = true;\n        }\n        catch (error) {\n        }\n    };\n    /**\n     * @return {?}\n     */\n    MdbInputDirective.prototype.onblur = function () {\n        this.validationFunction();\n        try {\n            if (this.el.nativeElement.value === '') {\n                this._renderer.removeClass(this.elLabel, 'active');\n            }\n            this.isClicked = false;\n        }\n        catch (error) {\n        }\n    };\n    /**\n     * @return {?}\n     */\n    MdbInputDirective.prototype.onchange = function () {\n        try {\n            this.checkValue();\n        }\n        catch (error) {\n        }\n    };\n    /**\n     * @return {?}\n     */\n    MdbInputDirective.prototype.oniput = function () {\n        this.validationFunction();\n    };\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n    MdbInputDirective.prototype.onkeydown = function (event) {\n        try {\n            if (event.target.type === 'number') {\n                if (event.shiftKey) {\n                    switch (event.keyCode) {\n                        case 38:\n                            event.target.value = +event.target.value + 10;\n                            break;\n                        case 40:\n                            event.target.value = +event.target.value - 10;\n                            break;\n                    }\n                }\n                if (event.altKey) {\n                    switch (event.keyCode) {\n                        case 38:\n                            event.target.value = +event.target.value + 0.1;\n                            break;\n                        case 40:\n                            event.target.value = +event.target.value - 0.1;\n                            break;\n                    }\n                }\n            }\n        }\n        catch (error) { }\n        this.delayedResize();\n    };\n    /**\n     * @return {?}\n     */\n    MdbInputDirective.prototype.oncut = function () {\n        var _this = this;\n        try {\n            setTimeout(function () {\n                _this.delayedResize();\n            }, 0);\n        }\n        catch (error) { }\n    };\n    /**\n     * @return {?}\n     */\n    MdbInputDirective.prototype.onpaste = function () {\n        var _this = this;\n        try {\n            setTimeout(function () {\n                _this.delayedResize();\n            }, 0);\n        }\n        catch (error) { }\n    };\n    /**\n     * @return {?}\n     */\n    MdbInputDirective.prototype.ondrop = function () {\n        var _this = this;\n        try {\n            setTimeout(function () {\n                _this.delayedResize();\n            }, 0);\n        }\n        catch (error) { }\n    };\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    MdbInputDirective.prototype.updateErrorMsg = function (value) {\n        if (this.wrongTextContainer) {\n            this.wrongTextContainer.innerHTML = value;\n        }\n    };\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    MdbInputDirective.prototype.updateSuccessMsg = function (value) {\n        if (this.rightTextContainer) {\n            this.rightTextContainer.innerHTML = value;\n        }\n    };\n    /**\n     * @return {?}\n     */\n    MdbInputDirective.prototype.ngOnInit = function () {\n        // Inititalise a new <span> wrong/right elements and render it below the host component.\n        if (this.mdbValidate) {\n            this.wrongTextContainer = this._renderer.createElement('span');\n            this._renderer.addClass(this.wrongTextContainer, 'inputVal');\n            this._renderer.addClass(this.wrongTextContainer, 'text-danger');\n            this._renderer.appendChild(this._elRef.nativeElement.parentElement, this.wrongTextContainer);\n            /** @type {?} */\n            var textWrong = this._elRef.nativeElement.getAttribute('data-error');\n            this.wrongTextContainer.innerHTML = (textWrong ? textWrong : 'wrong');\n            if (!textWrong) {\n                this.wrongTextContainer.innerHTML = (this.errorMessage ? this.errorMessage : 'wrong');\n            }\n            this._renderer.setStyle(this.wrongTextContainer, 'visibility', 'hidden');\n            this.rightTextContainer = this._renderer.createElement('span');\n            this._renderer.addClass(this.rightTextContainer, 'inputVal');\n            this._renderer.addClass(this.rightTextContainer, 'text-success');\n            this._renderer.appendChild(this._elRef.nativeElement.parentElement, this.rightTextContainer);\n            /** @type {?} */\n            var textSuccess = this._elRef.nativeElement.getAttribute('data-success');\n            this.rightTextContainer.innerHTML = (textSuccess ? textSuccess : 'success');\n            if (!textSuccess) {\n                this.rightTextContainer.innerHTML = (this.successMessage ? this.successMessage : 'success');\n            }\n            this._renderer.setStyle(this.rightTextContainer, 'visibility', 'hidden');\n        }\n    };\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n    MdbInputDirective.prototype.ngOnChanges = function (changes) {\n        if (changes.hasOwnProperty('errorMessage')) {\n            /** @type {?} */\n            var newErrorMsg = changes[\"errorMessage\"].currentValue;\n            this.updateErrorMsg(newErrorMsg);\n        }\n        if (changes.hasOwnProperty('successMessage')) {\n            /** @type {?} */\n            var newSuccessMsg = changes[\"successMessage\"].currentValue;\n            this.updateSuccessMsg(newSuccessMsg);\n        }\n    };\n    /**\n     * @return {?}\n     */\n    MdbInputDirective.prototype.ngDoCheck = function () {\n        if (this.mdbValidate &&\n            this._elRef.nativeElement.classList.contains('ng-valid') &&\n            this._elRef.nativeElement.classList.contains('ng-dirty') &&\n            !this._elRef.nativeElement.classList.contains('counter-success')) {\n            this._renderer.addClass(this._elRef.nativeElement, 'counter-success');\n            this._renderer.setStyle(this.wrongTextContainer, 'visibility', 'hidden');\n            this._renderer.setStyle(this.rightTextContainer, 'visibility', 'visible');\n            this._renderer.setStyle(this.rightTextContainer, 'top', this._elRef.nativeElement.offsetHeight + 'px');\n            this._renderer.setStyle(this.wrongTextContainer, 'top', this._elRef.nativeElement.offsetHeight + 'px');\n        }\n        if (this.mdbValidate &&\n            this._elRef.nativeElement.classList.contains('ng-invalid') &&\n            this._elRef.nativeElement.classList.contains('ng-dirty') &&\n            !this._elRef.nativeElement.classList.contains('counter-danger')) {\n            this._renderer.addClass(this._elRef.nativeElement, 'counter-danger');\n            this._renderer.setStyle(this.rightTextContainer, 'visibility', 'hidden');\n            this._renderer.setStyle(this.wrongTextContainer, 'visibility', 'visible');\n            this._renderer.setStyle(this.rightTextContainer, 'top', this._elRef.nativeElement.offsetHeight + 'px');\n            this._renderer.setStyle(this.wrongTextContainer, 'top', this._elRef.nativeElement.offsetHeight + 'px');\n        }\n        if (this._elRef.nativeElement.classList.contains('ng-invalid') &&\n            this._elRef.nativeElement.classList.contains('ng-pristine') &&\n            this._elRef.nativeElement.classList.contains('ng-untouched') || this._elRef.nativeElement.disabled) {\n            if (this._elRef.nativeElement.classList.contains('counter-success')) {\n                this._renderer.removeClass(this._elRef.nativeElement, 'counter-success');\n                this._renderer.setStyle(this.rightTextContainer, 'visibility', 'hidden');\n            }\n            else if (this._elRef.nativeElement.classList.contains('counter-danger')) {\n                this._renderer.removeClass(this._elRef.nativeElement, 'counter-danger');\n                this._renderer.setStyle(this.wrongTextContainer, 'visibility', 'hidden');\n            }\n        }\n        if (!this.validateSuccess) {\n            this._renderer.removeClass(this._elRef.nativeElement, 'counter-success');\n            this._renderer.setStyle(this.rightTextContainer, 'display', 'none');\n            if (this._elRef.nativeElement.classList.contains('ng-valid')) {\n                this._renderer.removeClass(this._elRef.nativeElement, 'counter-danger');\n            }\n        }\n        if (!this.validateError) {\n            this._renderer.removeClass(this._elRef.nativeElement, 'counter-danger');\n            this._renderer.setStyle(this.wrongTextContainer, 'display', 'none');\n            if (this._elRef.nativeElement.classList.contains('ng-invalid')) {\n                this._renderer.removeClass(this._elRef.nativeElement, 'counter-success');\n            }\n        }\n    };\n    /**\n     * @return {?}\n     */\n    MdbInputDirective.prototype.validationFunction = function () {\n        var _this = this;\n        setTimeout(function () {\n            if (_this._elRef.nativeElement.classList.contains('ng-invalid')) {\n                _this._renderer.removeClass(_this._elRef.nativeElement, 'counter-success');\n                _this._renderer.removeClass(_this._elRef.nativeElement, 'counter-danger');\n            }\n            if (_this._elRef.nativeElement.classList.contains('ng-touched') &&\n                _this._elRef.nativeElement.classList.contains('ng-invalid')) {\n                if (_this.mdbValidate) {\n                    _this._renderer.addClass(_this._elRef.nativeElement, 'counter-danger');\n                    _this._renderer.setStyle(_this.rightTextContainer, 'visibility', 'hidden');\n                    _this._renderer.setStyle(_this.wrongTextContainer, 'visibility', 'visible');\n                    _this._renderer.setStyle(_this.rightTextContainer, 'top', _this._elRef.nativeElement.offsetHeight + 'px');\n                    _this._renderer.setStyle(_this.wrongTextContainer, 'top', _this._elRef.nativeElement.offsetHeight + 'px');\n                }\n            }\n            else if (_this._elRef.nativeElement.classList.contains('ng-touched') &&\n                _this._elRef.nativeElement.classList.contains('ng-valid')) {\n                if (_this.mdbValidate) {\n                    _this._renderer.addClass(_this._elRef.nativeElement, 'counter-success');\n                    _this._renderer.setStyle(_this.rightTextContainer, 'visibility', 'visible');\n                    _this._renderer.setStyle(_this.wrongTextContainer, 'visibility', 'hidden');\n                    _this._renderer.setStyle(_this.rightTextContainer, 'top', _this._elRef.nativeElement.offsetHeight + 'px');\n                    _this._renderer.setStyle(_this.wrongTextContainer, 'top', _this._elRef.nativeElement.offsetHeight + 'px');\n                }\n            }\n        }, 0);\n    };\n    /**\n     * @return {?}\n     */\n    MdbInputDirective.prototype.ngAfterViewInit = function () {\n        if (this.isBrowser) {\n            try {\n                this.element = document.querySelector('.md-textarea-auto');\n            }\n            catch (error) { }\n        }\n        /** @type {?} */\n        var type = this.el.nativeElement.type;\n        if (this.focusCheckbox && type === 'checkbox') {\n            this._renderer.addClass(this.el.nativeElement, 'onFocusSelect');\n        }\n        if (this.focusRadio && type === 'radio') {\n            this._renderer.addClass(this.el.nativeElement, 'onFocusSelect');\n        }\n    };\n    /**\n     * @return {?}\n     */\n    MdbInputDirective.prototype.ngAfterViewChecked = function () {\n        this.initComponent();\n        this.checkValue();\n        // tslint:disable-next-line:max-line-length\n        /* if (this.el.nativeElement.tagName === 'MDB-COMPLETER' && this.el.nativeElement.getAttribute('ng-reflect-model') == null && !this.isClicked) {\n                this._renderer.removeClass(this.elLabel, 'active');\n            } */\n    };\n    /**\n     * @return {?}\n     */\n    MdbInputDirective.prototype.resize = function () {\n        if (this.el.nativeElement.classList.contains('md-textarea-auto')) {\n            this._renderer.setStyle(this.el.nativeElement, 'height', 'auto');\n            this._renderer.setStyle(this.el.nativeElement, 'height', this.el.nativeElement.scrollHeight + 'px');\n        }\n    };\n    /**\n     * @return {?}\n     */\n    MdbInputDirective.prototype.delayedResize = function () {\n        setTimeout(this.resize(), 0);\n    };\n    /**\n     * @return {?}\n     */\n    MdbInputDirective.prototype.initComponent = function () {\n        /** @type {?} */\n        var inputId;\n        /** @type {?} */\n        var inputP;\n        if (this.isBrowser) {\n            try {\n                inputId = this.el.nativeElement.id;\n            }\n            catch (err) { }\n            try {\n                inputP = this.el.nativeElement.parentNode;\n            }\n            catch (err) { }\n            this.elLabel = inputP.querySelector('label[for=\"' + inputId + '\"]') || inputP.querySelector('label');\n            if (this.elLabel && this.el.nativeElement.value !== '') {\n                this._renderer.addClass(this.elLabel, 'active');\n            }\n            this.elIcon = inputP.querySelector('i') || false;\n            if (this.elIcon) {\n                this._renderer.addClass(this.elIcon, 'active');\n            }\n        }\n    };\n    /**\n     * @return {?}\n     */\n    MdbInputDirective.prototype.checkValue = function () {\n        /** @type {?} */\n        var value = '';\n        if (this.elLabel != null) {\n            value = this.el.nativeElement.value || '';\n            if (value === '') {\n                this._renderer.removeClass(this.elLabel, 'active');\n                if (this.elIcon) {\n                    this._renderer.removeClass(this.elIcon, 'active');\n                }\n                // tslint:disable-next-line:max-line-length\n            }\n            if (value === '' && this.isClicked ||\n                value === '' && this.el.nativeElement.placeholder ||\n                value === '' && this.el.nativeElement.attributes.placeholder) {\n                this._renderer.addClass(this.elLabel, 'active');\n            }\n            if (this.el.nativeElement.getAttribute('ng-reflect-model') != null) {\n                // tslint:disable-next-line:max-line-length\n                /* if (this.el.nativeElement.tagName === 'MDB-COMPLETER' && this.el.nativeElement.getAttribute('ng-reflect-model').length !== 0) {\n                            this._renderer.addClass(this.elLabel, 'active');\n                        } */\n            }\n        }\n    };\n    return MdbInputDirective;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\nvar EqualValidatorDirective = /*@__PURE__*/ (function () {\n    /**\n     * @param {?} validateEqual\n     * @param {?} reverse\n     */\n    function EqualValidatorDirective(validateEqual, reverse) {\n        this.validateEqual = validateEqual;\n        this.reverse = reverse;\n    }\n    Object.defineProperty(EqualValidatorDirective.prototype, \"isReverse\", {\n        /**\n         * @return {?}\n         */\n        get: function () {\n            if (!this.reverse) {\n                return false;\n            }\n            return this.reverse === 'true' ? true : false;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @param {?} c\n     * @return {?}\n     */\n    EqualValidatorDirective.prototype.validate = function (c) {\n        /** @type {?} */\n        var setToNullValue = null;\n        /** @type {?} */\n        var v = c.value;\n        /** @type {?} */\n        var e = c.root.get(this.validateEqual);\n        // value not equal\n        if (e && v !== e.value) {\n            return { validateEqual: false };\n        }\n        // value equal and reverse\n        if (e && v === e.value && this.isReverse) {\n            delete e.errors['validateEqual'];\n            if (!Object.keys(e.errors).length) {\n                e.setErrors(null);\n            }\n        }\n        // value not equal and reverse\n        if (e && v !== e.value && this.isReverse) {\n            e.setErrors({\n                validateEqual: false\n            });\n        }\n        // return null;\n        return setToNullValue;\n    };\n    return EqualValidatorDirective;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\nvar InputsModule = /*@__PURE__*/ (function () {\n    function InputsModule() {\n    }\n    /**\n     * @return {?}\n     */\n    InputsModule.forRoot = function () {\n        return { ngModule: InputsModule, providers: [] };\n    };\n    return InputsModule;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\nvar NavbarService = /*@__PURE__*/ (function () {\n    function NavbarService() {\n        this.navbarLinkClicks = new Subject();\n    }\n    /**\n     * @return {?}\n     */\n    NavbarService.prototype.getNavbarLinkClicks = function () {\n        return this.navbarLinkClicks.asObservable();\n    };\n    /**\n     * @return {?}\n     */\n    NavbarService.prototype.setNavbarLinkClicks = function () {\n        this.navbarLinkClicks.next();\n    };\n    return NavbarService;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\nvar LinksComponent = /*@__PURE__*/ (function () {\n    /**\n     * @param {?} _navbarService\n     */\n    function LinksComponent(_navbarService) {\n        this._navbarService = _navbarService;\n        this.linkClick = new EventEmitter();\n    }\n    /**\n     * @return {?}\n     */\n    LinksComponent.prototype.ngAfterContentInit = function () {\n        /** @type {?} */\n        var that = this;\n        setTimeout(function () {\n            that.links.forEach(function (element) {\n                element.nativeElement.onclick = function () {\n                    that._navbarService.setNavbarLinkClicks();\n                };\n            });\n        }, 0);\n    };\n    /**\n     * @return {?}\n     */\n    LinksComponent.prototype.ngAfterViewInit = function () {\n    };\n    return LinksComponent;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\nvar LogoComponent = /*@__PURE__*/ (function () {\n    function LogoComponent() {\n    }\n    return LogoComponent;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\nvar NavbarComponent = /*@__PURE__*/ (function () {\n    /**\n     * @param {?} renderer\n     * @param {?} _navbarService\n     */\n    function NavbarComponent(renderer, _navbarService) {\n        var _this = this;\n        this.renderer = renderer;\n        this._navbarService = _navbarService;\n        this.containerInside = true;\n        this.shown = false;\n        this.duration = 350;\n        this.collapse = false;\n        this.showClass = false;\n        this.collapsing = false;\n        // tslint:disable-next-line:max-line-length\n        this.subscription = this._navbarService.getNavbarLinkClicks().subscribe(function (navbarLinkClicks) { _this.closeNavbarOnClick(navbarLinkClicks); });\n    }\n    /**\n     * @param {?} navbarLinkClicks\n     * @return {?}\n     */\n    NavbarComponent.prototype.closeNavbarOnClick = function (navbarLinkClicks) {\n        this.navbarLinkClicks = navbarLinkClicks;\n        if (this.showClass) {\n            this.hide();\n        }\n    };\n    /**\n     * @return {?}\n     */\n    NavbarComponent.prototype.addTogglerIconClasses = function () {\n        var _this = this;\n        if (this.iconBackground) {\n            if (Array.isArray(this.iconBackground)) {\n                this.iconBackground.forEach(function (iconClass) {\n                    _this.renderer.addClass(_this.toggler.nativeElement, iconClass);\n                });\n            }\n            else {\n                this.renderer.addClass(this.toggler.nativeElement, this.iconBackground);\n            }\n        }\n    };\n    /**\n     * @return {?}\n     */\n    NavbarComponent.prototype.ngOnInit = function () {\n        /** @type {?} */\n        var isDoubleNav = this.SideClass.split(' ');\n        if (isDoubleNav.indexOf('double-nav') !== -1) {\n            this.doubleNav = true;\n        }\n        else {\n            this.doubleNav = false;\n        }\n    };\n    /**\n     * @return {?}\n     */\n    NavbarComponent.prototype.ngAfterViewInit = function () {\n        var _this = this;\n        /* bugfix - bez tego sypie ExpressionChangedAfterItHasBeenCheckedError -\n            https://github.com/angular/angular/issues/6005#issuecomment-165951692 */\n        setTimeout(function () {\n            _this.height = _this.el.nativeElement.scrollHeight;\n            _this.collapse = true;\n            if (!_this.containerInside) {\n                /** @type {?} */\n                var childrens = Array.from(_this.container.nativeElement.children);\n                childrens.forEach(function (child) {\n                    // this.navbar.nativeElement.append(child);\n                    _this.renderer.appendChild(_this.navbar.nativeElement, child);\n                    _this.container.nativeElement.remove();\n                });\n            }\n            if (_this.el.nativeElement.children.length === 0) {\n                _this.el.nativeElement.remove();\n            }\n        });\n        this.addTogglerIconClasses();\n    };\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n    NavbarComponent.prototype.toggle = function (event) {\n        event.preventDefault();\n        if (!this.collapsing) {\n            if (this.shown) {\n                this.hide();\n            }\n            else {\n                this.show();\n            }\n        }\n    };\n    /**\n     * @return {?}\n     */\n    NavbarComponent.prototype.show = function () {\n        var _this = this;\n        this.shown = true;\n        this.collapse = false;\n        this.collapsing = true;\n        setTimeout(function () {\n            _this.renderer.setStyle(_this.el.nativeElement, 'height', _this.height + 'px');\n        }, 10);\n        setTimeout(function () {\n            _this.collapsing = false;\n            _this.collapse = true;\n            _this.showClass = true;\n        }, this.duration);\n    };\n    /**\n     * @return {?}\n     */\n    NavbarComponent.prototype.hide = function () {\n        var _this = this;\n        this.shown = false;\n        this.collapse = false;\n        this.showClass = false;\n        this.collapsing = true;\n        setTimeout(function () {\n            _this.renderer.setStyle(_this.el.nativeElement, 'height', '0px');\n        }, 10);\n        setTimeout(function () {\n            _this.collapsing = false;\n            _this.collapse = true;\n        }, this.duration);\n    };\n    Object.defineProperty(NavbarComponent.prototype, \"displayStyle\", {\n        /**\n         * @return {?}\n         */\n        get: function () {\n            if (!this.containerInside) {\n                return 'flex';\n            }\n            else {\n                return '';\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n    NavbarComponent.prototype.onResize = function (event) {\n        var _this = this;\n        /** @type {?} */\n        var breakpoit = 0;\n        if (this.SideClass.includes('navbar-expand-xl')) {\n            breakpoit = 1200;\n        }\n        else if (this.SideClass.includes('navbar-expand-lg')) {\n            breakpoit = 992;\n        }\n        else if (this.SideClass.includes('navbar-expand-md')) {\n            breakpoit = 768;\n        }\n        else if (this.SideClass.includes('navbar-expand-sm')) {\n            breakpoit = 576;\n        }\n        else {\n            breakpoit = event.target.innerWidth + 1;\n        }\n        if (event.target.innerWidth < breakpoit) {\n            if (!this.shown) {\n                this.collapse = false;\n                this.renderer.setStyle(this.el.nativeElement, 'height', '0px');\n                this.renderer.setStyle(this.el.nativeElement, 'opacity', '0');\n                setTimeout(function () {\n                    _this.height = _this.el.nativeElement.scrollHeight;\n                    _this.collapse = true;\n                    _this.renderer.setStyle(_this.el.nativeElement, 'opacity', '');\n                }, 4);\n            }\n        }\n        else {\n            this.collapsing = false;\n            this.shown = false;\n            this.showClass = false;\n            this.collapse = true;\n            this.renderer.setStyle(this.el.nativeElement, 'height', '');\n        }\n    };\n    /**\n     * @return {?}\n     */\n    NavbarComponent.prototype.onScroll = function () {\n        if (this.navbar.nativeElement.classList.contains('scrolling-navbar')) {\n            if (window.pageYOffset > 120) {\n                this.renderer.addClass(this.navbar.nativeElement, 'top-nav-collapse');\n            }\n            else {\n                this.renderer.removeClass(this.navbar.nativeElement, 'top-nav-collapse');\n            }\n        }\n    };\n    return NavbarComponent;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\nvar NavlinksComponent = /*@__PURE__*/ (function () {\n    /**\n     * @param {?} _navbarService\n     */\n    function NavlinksComponent(_navbarService) {\n        this._navbarService = _navbarService;\n        this.linkClick = new EventEmitter();\n    }\n    /**\n     * @return {?}\n     */\n    NavlinksComponent.prototype.ngAfterContentInit = function () {\n        /** @type {?} */\n        var that = this;\n        setTimeout(function () {\n            that.links.forEach(function (element) {\n                element.nativeElement.onclick = function () {\n                    that._navbarService.setNavbarLinkClicks();\n                };\n            });\n        }, 0);\n    };\n    /**\n     * @return {?}\n     */\n    NavlinksComponent.prototype.ngAfterViewInit = function () {\n    };\n    return NavlinksComponent;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\nvar NavbarModule = /*@__PURE__*/ (function () {\n    function NavbarModule() {\n    }\n    return NavbarModule;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * @copyright Valor Software\n * @copyright Angular ng-bootstrap team\n */\nvar Trigger = /*@__PURE__*/ (function () {\n    /**\n     * @param {?} open\n     * @param {?=} close\n     */\n    function Trigger(open, close) {\n        this.open = open;\n        this.close = close || open;\n    }\n    /**\n     * @return {?}\n     */\n    Trigger.prototype.isManual = function () { return this.open === 'manual' || this.close === 'manual'; };\n    return Trigger;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/** @type {?} */\nvar DEFAULT_ALIASES = {\n    hover: ['mouseover', 'mouseout'],\n    focus: ['focusin', 'focusout']\n};\n/**\n * @param {?} triggers\n * @param {?=} aliases\n * @return {?}\n */\nfunction parseTriggers(triggers, aliases) {\n    if (aliases === void 0) {\n        aliases = DEFAULT_ALIASES;\n    }\n    /** @type {?} */\n    var trimmedTriggers = (triggers || '').trim();\n    if (trimmedTriggers.length === 0) {\n        return [];\n    }\n    /** @type {?} */\n    var parsedTriggers = trimmedTriggers.split(/\\s+/)\n        .map(function (trigger$$1) { return trigger$$1.split(':'); })\n        .map(function (triggerPair) {\n        /** @type {?} */\n        var alias = aliases[triggerPair[0]] || triggerPair;\n        return new Trigger(alias[0], alias[1]);\n    });\n    /** @type {?} */\n    var manualTriggers = parsedTriggers\n        .filter(function (triggerPair) { return triggerPair.isManual(); });\n    if (manualTriggers.length > 1) {\n        throw new Error('Triggers parse error: only one manual trigger is allowed');\n    }\n    if (manualTriggers.length === 1 && parsedTriggers.length > 1) {\n        throw new Error('Triggers parse error: manual trigger can\\'t be mixed with other triggers');\n    }\n    return parsedTriggers;\n}\n/**\n * @param {?} renderer\n * @param {?} target\n * @param {?} triggers\n * @param {?} showFn\n * @param {?} hideFn\n * @param {?} toggleFn\n * @return {?}\n */\nfunction listenToTriggers(renderer, target, triggers, showFn, hideFn, toggleFn) {\n    /** @type {?} */\n    var parsedTriggers = parseTriggers(triggers);\n    /** @type {?} */\n    var listeners = [];\n    if (parsedTriggers.length === 1 && parsedTriggers[0].isManual()) {\n        return Function.prototype;\n    }\n    //  parsedTriggers.forEach((trigger: Trigger) => {\n    parsedTriggers.forEach(function (trigger$$1) {\n        if (trigger$$1.open === trigger$$1.close) {\n            listeners.push(renderer.listen(target, trigger$$1.open, function () {\n                toggleFn();\n            }));\n            // listeners.push(renderer.listen(target, trigger.open, toggleFn));\n            return;\n        }\n        listeners.push(renderer.listen(target, trigger$$1.open, function () {\n            showFn();\n        }), \n        // renderer.listen(target, trigger.open, showFn),\n        renderer.listen(target, trigger$$1.close, function () {\n            hideFn();\n        }));\n        // renderer.listen(target, trigger.close, hideFn));\n    });\n    return function () { listeners.forEach(function (unsubscribeFn) { return unsubscribeFn(); }); };\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * @copyright Valor Software\n * @copyright Angular ng-bootstrap team\n */\nvar ContentRef = /*@__PURE__*/ (function () {\n    /**\n     * @param {?} nodes\n     * @param {?=} viewRef\n     * @param {?=} componentRef\n     */\n    function ContentRef(nodes, viewRef, componentRef) {\n        this.nodes = nodes;\n        this.viewRef = viewRef;\n        this.componentRef = componentRef;\n    }\n    return ContentRef;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * @record\n */\n/**\n * @template T\n */\nvar ComponentLoader = /*@__PURE__*/ (function () {\n    /**\n     * Do not use this directly, it should be instanced via\n     * `ComponentLoadFactory.attach`\n     * \\@internal\n     * @param {?} _viewContainerRef\n     * @param {?} _renderer\n     * @param {?} _elementRef\n     * @param {?} _injector\n     * @param {?} _componentFactoryResolver\n     * @param {?} _ngZone\n     * @param {?} _applicationRef\n     * @param {?} _posService\n     */\n    function ComponentLoader(_viewContainerRef, _renderer, _elementRef, _injector, _componentFactoryResolver, _ngZone, _applicationRef, _posService) {\n        this._viewContainerRef = _viewContainerRef;\n        this._renderer = _renderer;\n        this._elementRef = _elementRef;\n        this._injector = _injector;\n        this._componentFactoryResolver = _componentFactoryResolver;\n        this._ngZone = _ngZone;\n        this._applicationRef = _applicationRef;\n        this._posService = _posService;\n        this.onBeforeShow = new EventEmitter();\n        this.onShown = new EventEmitter();\n        this.shown = new EventEmitter();\n        this.onBeforeHide = new EventEmitter();\n        this.onHidden = new EventEmitter();\n        this.hidden = new EventEmitter();\n        this._providers = [];\n    }\n    Object.defineProperty(ComponentLoader.prototype, \"isShown\", {\n        /**\n         * @return {?}\n         */\n        get: function () {\n            return !!this._componentRef;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @param {?} compType\n     * @return {?}\n     */\n    ComponentLoader.prototype.attach = function (compType) {\n        this._componentFactory = this._componentFactoryResolver\n            .resolveComponentFactory(compType);\n        return this;\n    };\n    /**\n     * @param {?=} container\n     * @return {?}\n     */\n    ComponentLoader.prototype.to = function (container) {\n        this.container = container || this.container;\n        return this;\n    };\n    /**\n     * @param {?=} opts\n     * @return {?}\n     */\n    ComponentLoader.prototype.position = function (opts) {\n        this.attachment = opts.attachment || this.attachment;\n        this._elementRef = /** @type {?} */ (opts.target) || this._elementRef;\n        return this;\n    };\n    /**\n     * @param {?} provider\n     * @return {?}\n     */\n    ComponentLoader.prototype.provide = function (provider) {\n        this._providers.push(provider);\n        return this;\n    };\n    /**\n     * @param {?=} opts\n     * @return {?}\n     */\n    ComponentLoader.prototype.show = function (opts) {\n        if (opts === void 0) {\n            opts = {};\n        }\n        this._subscribePositioning();\n        this._innerComponent = null;\n        if (!this._componentRef) {\n            this.onBeforeShow.emit();\n            this._contentRef = this._getContentRef(opts.content);\n            /** @type {?} */\n            var injector = ReflectiveInjector.resolveAndCreate(this._providers, this._injector);\n            this._componentRef = this._componentFactory.create(injector, this._contentRef.nodes);\n            this._applicationRef.attachView(this._componentRef.hostView);\n            // this._componentRef = this._viewContainerRef\n            //   .createComponent(this._componentFactory, 0, injector, this._contentRef.nodes);\n            this.instance = this._componentRef.instance;\n            Object.assign(this._componentRef.instance, opts);\n            if (this.container instanceof ElementRef) {\n                this.container.nativeElement\n                    .appendChild(this._componentRef.location.nativeElement);\n            }\n            if (this.container === 'body' && typeof document !== 'undefined') {\n                //  document.querySelector(this.container as string)\n                document.querySelector(/** @type {?} */ (this.container))\n                    .appendChild(this._componentRef.location.nativeElement);\n            }\n            if (!this.container && this._elementRef && this._elementRef.nativeElement.parentElement) {\n                this._elementRef.nativeElement.parentElement\n                    .appendChild(this._componentRef.location.nativeElement);\n            }\n            // we need to manually invoke change detection since events registered\n            // via\n            // Renderer::listen() are not picked up by change detection with the\n            // OnPush strategy\n            if (this._contentRef.componentRef) {\n                this._innerComponent = this._contentRef.componentRef.instance;\n                this._contentRef.componentRef.changeDetectorRef.markForCheck();\n                this._contentRef.componentRef.changeDetectorRef.detectChanges();\n            }\n            this._componentRef.changeDetectorRef.markForCheck();\n            this._componentRef.changeDetectorRef.detectChanges();\n            this.onShown.emit(this._componentRef.instance);\n        }\n        return this._componentRef;\n    };\n    /**\n     * @return {?}\n     */\n    ComponentLoader.prototype.hide = function () {\n        if (!this._componentRef) {\n            return this;\n        }\n        this.onBeforeHide.emit(this._componentRef.instance);\n        /** @type {?} */\n        var componentEl = this._componentRef.location.nativeElement;\n        componentEl.parentNode.removeChild(componentEl);\n        if (this._contentRef.componentRef) {\n            this._contentRef.componentRef.destroy();\n        }\n        this._componentRef.destroy();\n        if (this._viewContainerRef && this._contentRef.viewRef) {\n            this._viewContainerRef.remove(this._viewContainerRef.indexOf(this._contentRef.viewRef));\n        }\n        // this._viewContainerRef.remove(this._viewContainerRef.indexOf(this._componentRef.hostView));\n        //\n        // if (this._contentRef.viewRef && this._viewContainerRef.indexOf(this._contentRef.viewRef) !== -1) {\n        //   this._viewContainerRef.remove(this._viewContainerRef.indexOf(this._contentRef.viewRef));\n        // }\n        this._contentRef = null;\n        this._componentRef = null;\n        this.onHidden.emit();\n        return this;\n    };\n    /**\n     * @return {?}\n     */\n    ComponentLoader.prototype.toggle = function () {\n        if (this.isShown) {\n            this.hide();\n            return;\n        }\n        this.show();\n    };\n    /**\n     * @return {?}\n     */\n    ComponentLoader.prototype.dispose = function () {\n        if (this.isShown) {\n            this.hide();\n        }\n        this._unsubscribePositioning();\n        if (this._unregisterListenersFn) {\n            this._unregisterListenersFn();\n        }\n    };\n    /**\n     * @param {?} listenOpts\n     * @return {?}\n     */\n    ComponentLoader.prototype.listen = function (listenOpts) {\n        var _this = this;\n        this.triggers = listenOpts.triggers || this.triggers;\n        listenOpts.target = listenOpts.target || this._elementRef;\n        listenOpts.show = listenOpts.show || (function () { return _this.show(); });\n        listenOpts.hide = listenOpts.hide || (function () { return _this.hide(); });\n        listenOpts.toggle = listenOpts.toggle || (function () {\n            return _this.isShown\n                ? listenOpts.hide()\n                : listenOpts.show();\n        });\n        this._unregisterListenersFn = listenToTriggers(this._renderer, listenOpts.target.nativeElement, this.triggers, listenOpts.show, listenOpts.hide, listenOpts.toggle);\n        return this;\n    };\n    /**\n     * @return {?}\n     */\n    ComponentLoader.prototype.getInnerComponent = function () {\n        return this._innerComponent;\n    };\n    /**\n     * @return {?}\n     */\n    ComponentLoader.prototype._subscribePositioning = function () {\n        var _this = this;\n        if (this._zoneSubscription || !this.attachment) {\n            return;\n        }\n        this._zoneSubscription = this._ngZone\n            .onStable.subscribe(function () {\n            if (!_this._componentRef) {\n                return;\n            }\n            _this._posService.position({\n                element: _this._componentRef.location,\n                target: _this._elementRef,\n                attachment: _this.attachment,\n                appendToBody: _this.container === 'body'\n            });\n        });\n    };\n    /**\n     * @return {?}\n     */\n    ComponentLoader.prototype._unsubscribePositioning = function () {\n        if (!this._zoneSubscription) {\n            return;\n        }\n        this._zoneSubscription.unsubscribe();\n        this._zoneSubscription = null;\n    };\n    /**\n     * @param {?} content\n     * @return {?}\n     */\n    ComponentLoader.prototype._getContentRef = function (content) {\n        if (!content) {\n            return new ContentRef([]);\n        }\n        if (content instanceof TemplateRef) {\n            if (this._viewContainerRef) {\n                /** @type {?} */\n                var viewRef_1 = this._viewContainerRef.createEmbeddedView(content);\n                return new ContentRef([viewRef_1.rootNodes], viewRef_1);\n            }\n            /** @type {?} */\n            var viewRef = content.createEmbeddedView({});\n            this._applicationRef.attachView(viewRef);\n            return new ContentRef([viewRef.rootNodes], viewRef);\n        }\n        if (typeof content === 'function') {\n            /** @type {?} */\n            var contentCmptFactory = this._componentFactoryResolver.resolveComponentFactory(content);\n            /** @type {?} */\n            var modalContentInjector = ReflectiveInjector.resolveAndCreate(this._providers.concat([content]), this._injector);\n            /** @type {?} */\n            var componentRef = contentCmptFactory.create(modalContentInjector);\n            this._applicationRef.attachView(componentRef.hostView);\n            return new ContentRef([[componentRef.location.nativeElement]], componentRef.hostView, componentRef);\n        }\n        return new ContentRef([[this._renderer.createText(\"\" + content)]]);\n    };\n    return ComponentLoader;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * @copyright Valor Software\n * @copyright Angular ng-bootstrap team\n */\nvar Positioning = /*@__PURE__*/ (function () {\n    function Positioning() {\n    }\n    /**\n     * @param {?} element\n     * @param {?=} round\n     * @return {?}\n     */\n    Positioning.prototype.position = function (element, round) {\n        if (round === void 0) {\n            round = true;\n        }\n        /** @type {?} */\n        var elPosition;\n        /** @type {?} */\n        var parentOffset = { width: 0, height: 0, top: 0, bottom: 0, left: 0, right: 0 };\n        if (this.getStyle(element, 'position') === 'fixed') {\n            /** @type {?} */\n            var bcRect = element.getBoundingClientRect();\n            elPosition = {\n                width: bcRect.width,\n                height: bcRect.height,\n                top: bcRect.top,\n                bottom: bcRect.bottom,\n                left: bcRect.left,\n                right: bcRect.right\n            };\n        }\n        else {\n            /** @type {?} */\n            var offsetParentEl = this.offsetParent(element);\n            elPosition = this.offset(element, false);\n            if (offsetParentEl !== document.documentElement) {\n                parentOffset = this.offset(offsetParentEl, false);\n            }\n            parentOffset.top += offsetParentEl.clientTop;\n            parentOffset.left += offsetParentEl.clientLeft;\n        }\n        elPosition.top -= parentOffset.top;\n        elPosition.bottom -= parentOffset.top;\n        elPosition.left -= parentOffset.left;\n        elPosition.right -= parentOffset.left;\n        if (round) {\n            elPosition.top = Math.round(elPosition.top);\n            elPosition.bottom = Math.round(elPosition.bottom);\n            elPosition.left = Math.round(elPosition.left);\n            elPosition.right = Math.round(elPosition.right);\n        }\n        return elPosition;\n    };\n    /**\n     * @param {?} element\n     * @param {?=} round\n     * @return {?}\n     */\n    Positioning.prototype.offset = function (element, round) {\n        if (round === void 0) {\n            round = true;\n        }\n        /** @type {?} */\n        var elBcr = element.getBoundingClientRect();\n        /** @type {?} */\n        var viewportOffset = {\n            top: window.pageYOffset - document.documentElement.clientTop,\n            left: window.pageXOffset - document.documentElement.clientLeft\n        };\n        /** @type {?} */\n        var elOffset = {\n            height: elBcr.height || element.offsetHeight,\n            width: elBcr.width || element.offsetWidth,\n            top: elBcr.top + viewportOffset.top,\n            bottom: elBcr.bottom + viewportOffset.top,\n            left: elBcr.left + viewportOffset.left,\n            right: elBcr.right + viewportOffset.left\n        };\n        if (round) {\n            elOffset.height = Math.round(elOffset.height);\n            elOffset.width = Math.round(elOffset.width);\n            elOffset.top = Math.round(elOffset.top);\n            elOffset.bottom = Math.round(elOffset.bottom);\n            elOffset.left = Math.round(elOffset.left);\n            elOffset.right = Math.round(elOffset.right);\n        }\n        return elOffset;\n    };\n    /**\n     * @param {?} hostElement\n     * @param {?} targetElement\n     * @param {?} placement\n     * @param {?=} appendToBody\n     * @return {?}\n     */\n    Positioning.prototype.positionElements = function (hostElement, targetElement, placement, appendToBody) {\n        /** @type {?} */\n        var hostElPosition = appendToBody ? this.offset(hostElement, false) : this.position(hostElement, false);\n        /** @type {?} */\n        var shiftWidth = {\n            left: hostElPosition.left,\n            center: hostElPosition.left + hostElPosition.width / 2 - targetElement.offsetWidth / 2,\n            right: hostElPosition.left + hostElPosition.width\n        };\n        /** @type {?} */\n        var shiftHeight = {\n            top: hostElPosition.top,\n            center: hostElPosition.top + hostElPosition.height / 2 - targetElement.offsetHeight / 2,\n            bottom: hostElPosition.top + hostElPosition.height\n        };\n        /** @type {?} */\n        var targetElBCR = targetElement.getBoundingClientRect();\n        /** @type {?} */\n        var placementPrimary = placement.split(' ')[0] || 'top';\n        /** @type {?} */\n        var placementSecondary = placement.split(' ')[1] || 'center';\n        /** @type {?} */\n        var targetElPosition = {\n            height: targetElBCR.height || targetElement.offsetHeight,\n            width: targetElBCR.width || targetElement.offsetWidth,\n            top: 0,\n            bottom: targetElBCR.height || targetElement.offsetHeight,\n            left: 0,\n            right: targetElBCR.width || targetElement.offsetWidth\n        };\n        switch (placementPrimary) {\n            case 'top':\n                targetElPosition.top = hostElPosition.top - targetElement.offsetHeight;\n                targetElPosition.bottom += hostElPosition.top - targetElement.offsetHeight;\n                targetElPosition.left = shiftWidth[placementSecondary];\n                targetElPosition.right += shiftWidth[placementSecondary];\n                break;\n            case 'bottom':\n                targetElPosition.top = shiftHeight[placementPrimary];\n                targetElPosition.bottom += shiftHeight[placementPrimary];\n                targetElPosition.left = shiftWidth[placementSecondary];\n                targetElPosition.right += shiftWidth[placementSecondary];\n                break;\n            case 'left':\n                targetElPosition.top = shiftHeight[placementSecondary];\n                targetElPosition.bottom += shiftHeight[placementSecondary];\n                targetElPosition.left = hostElPosition.left - targetElement.offsetWidth;\n                targetElPosition.right += hostElPosition.left - targetElement.offsetWidth;\n                break;\n            case 'right':\n                targetElPosition.top = shiftHeight[placementSecondary];\n                targetElPosition.bottom += shiftHeight[placementSecondary];\n                targetElPosition.left = shiftWidth[placementPrimary];\n                targetElPosition.right += shiftWidth[placementPrimary];\n                break;\n        }\n        targetElPosition.top = Math.round(targetElPosition.top);\n        targetElPosition.bottom = Math.round(targetElPosition.bottom);\n        targetElPosition.left = Math.round(targetElPosition.left);\n        targetElPosition.right = Math.round(targetElPosition.right);\n        return targetElPosition;\n    };\n    /**\n     * @param {?} element\n     * @param {?} prop\n     * @return {?}\n     */\n    Positioning.prototype.getStyle = function (element, prop) { return ((window.getComputedStyle(element)))[prop]; };\n    /**\n     * @param {?} element\n     * @return {?}\n     */\n    Positioning.prototype.isStaticPositioned = function (element) {\n        return (this.getStyle(element, 'position') || 'static') === 'static';\n    };\n    /**\n     * @param {?} element\n     * @return {?}\n     */\n    Positioning.prototype.offsetParent = function (element) {\n        /** @type {?} */\n        var offsetParentEl = (element.offsetParent) || document.documentElement;\n        while (offsetParentEl && offsetParentEl !== document.documentElement && this.isStaticPositioned(offsetParentEl)) {\n            offsetParentEl = /** @type {?} */ (offsetParentEl.offsetParent);\n        }\n        return offsetParentEl || document.documentElement;\n    };\n    return Positioning;\n}());\n/** @type {?} */\nvar positionService = new Positioning();\n/**\n * @param {?} hostElement\n * @param {?} targetElement\n * @param {?} placement\n * @param {?=} appendToBody\n * @return {?}\n */\nfunction positionElements(hostElement, targetElement, placement, appendToBody) {\n    /** @type {?} */\n    var pos = positionService.positionElements(hostElement, targetElement, placement, appendToBody);\n    targetElement.style.top = pos.top + \"px\";\n    targetElement.style.left = pos.left + \"px\";\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * @record\n */\nvar PositioningService = /*@__PURE__*/ (function () {\n    function PositioningService() {\n    }\n    /**\n     * @param {?} options\n     * @return {?}\n     */\n    PositioningService.prototype.position = function (options) {\n        var element = options.element, target = options.target, attachment = options.attachment, appendToBody = options.appendToBody;\n        positionElements(this._getHtmlElement(target), this._getHtmlElement(element), attachment, appendToBody);\n    };\n    /**\n     * @param {?} element\n     * @return {?}\n     */\n    PositioningService.prototype._getHtmlElement = function (element) {\n        // it means that we got a selector\n        if (typeof element === 'string') {\n            return /** @type {?} */ (document.querySelector(element));\n        }\n        if (element instanceof ElementRef) {\n            return element.nativeElement;\n        }\n        return /** @type {?} */ (element);\n    };\n    return PositioningService;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\nvar ComponentLoaderFactory = /*@__PURE__*/ (function () {\n    /**\n     * @param {?} _componentFactoryResolver\n     * @param {?} _ngZone\n     * @param {?} _injector\n     * @param {?} _posService\n     * @param {?} _applicationRef\n     */\n    function ComponentLoaderFactory(_componentFactoryResolver, _ngZone, _injector, _posService, _applicationRef) {\n        this._componentFactoryResolver = _componentFactoryResolver;\n        this._ngZone = _ngZone;\n        this._injector = _injector;\n        this._posService = _posService;\n        this._applicationRef = _applicationRef;\n    }\n    /**\n     *\n     * @template T\n     * @param {?} _elementRef\n     * @param {?} _viewContainerRef\n     * @param {?} _renderer\n     * @return {?}\n     */\n    ComponentLoaderFactory.prototype.createLoader = function (_elementRef, _viewContainerRef, _renderer) {\n        return new ComponentLoader(_viewContainerRef, _renderer, _elementRef, this._injector, this._componentFactoryResolver, this._ngZone, this._applicationRef, this._posService);\n    };\n    return ComponentLoaderFactory;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\nvar BsDropdownState = /*@__PURE__*/ (function () {\n    function BsDropdownState() {\n        var _this = this;\n        this.direction = 'down';\n        this.isOpenChange = new EventEmitter();\n        this.isDisabledChange = new EventEmitter();\n        this.toggleClick = new EventEmitter();\n        this.dropdownMenu = new Promise(function (resolve) {\n            _this.resolveDropdownMenu = resolve;\n        });\n    }\n    return BsDropdownState;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\nvar BsDropdownContainerComponent = /*@__PURE__*/ (function () {\n    /**\n     * @param {?} _state\n     */\n    function BsDropdownContainerComponent(_state) {\n        var _this = this;\n        this._state = _state;\n        this.isOpen = false;\n        this.display = 'block';\n        this.position = 'absolute';\n        this._subscription = _state.isOpenChange.subscribe(function (value) {\n            _this.isOpen = value;\n        });\n    }\n    Object.defineProperty(BsDropdownContainerComponent.prototype, \"direction\", {\n        /**\n         * @return {?}\n         */\n        get: function () {\n            return this._state.direction;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    BsDropdownContainerComponent.prototype.ngOnDestroy = function () {\n        this._subscription.unsubscribe();\n    };\n    return BsDropdownContainerComponent;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\nvar BsDropdownMenuDirective = /*@__PURE__*/ (function () {\n    /**\n     * @param {?} _state\n     * @param {?} _viewContainer\n     * @param {?} _templateRef\n     */\n    function BsDropdownMenuDirective(_state, _viewContainer, _templateRef) {\n        _state.resolveDropdownMenu({\n            templateRef: _templateRef,\n            viewContainer: _viewContainer\n        });\n    }\n    return BsDropdownMenuDirective;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\nvar BsDropdownToggleDirective = /*@__PURE__*/ (function () {\n    /**\n     * @param {?} _state\n     * @param {?} _element\n     */\n    function BsDropdownToggleDirective(_state, _element) {\n        var _this = this;\n        this._state = _state;\n        this._element = _element;\n        this._subscriptions = [];\n        this.ariaHaspopup = true;\n        // @HostBinding('attr.disabled') isDisabled: boolean = null;\n        this.isDisabled = null;\n        // sync is open value with state\n        this._subscriptions.push(this._state\n            .isOpenChange.subscribe(function (value) { return _this.isOpen = value; }));\n        // populate disabled state\n        this._subscriptions.push(this._state\n            .isDisabledChange\n            .subscribe(function (value) { return _this.isDisabled = value || null; }));\n    }\n    /**\n     * @return {?}\n     */\n    BsDropdownToggleDirective.prototype.onClick = function () {\n        if (this.isDisabled) {\n            return;\n        }\n        this._state.toggleClick.emit();\n    };\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n    BsDropdownToggleDirective.prototype.onDocumentClick = function (event) {\n        if (this._state.autoClose && event.button !== 2 &&\n            !this._element.nativeElement.contains(event.target)) {\n            this._state.toggleClick.emit(false);\n        }\n    };\n    /**\n     * @return {?}\n     */\n    BsDropdownToggleDirective.prototype.onEsc = function () {\n        if (this._state.autoClose) {\n            this._state.toggleClick.emit(false);\n        }\n    };\n    /**\n     * @return {?}\n     */\n    BsDropdownToggleDirective.prototype.ngOnDestroy = function () {\n        for (var _i = 0, _a = this._subscriptions; _i < _a.length; _i++) {\n            var sub = _a[_i];\n            sub.unsubscribe();\n        }\n    };\n    return BsDropdownToggleDirective;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * Default dropdown configuration\n */\nvar BsDropdownConfig = /*@__PURE__*/ (function () {\n    function BsDropdownConfig() {\n        /**\n         * default dropdown auto closing behavior\n         */\n        this.autoClose = true;\n    }\n    return BsDropdownConfig;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/*tslint:disable */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** *\n * JS version of browser APIs. This library can only run in the browser.\n  @type {?} */\nvar win = typeof window !== 'undefined' && window || /** @type {?} */ ({});\n/** @type {?} */\nvar document$1 = win.document;\n/** @type {?} */\nvar location = win.location;\n/** @type {?} */\nvar gc = win['gc'] ? function () { return win['gc'](); } : function () { return null; };\n/** @type {?} */\nvar performance = win['performance'] ? win['performance'] : null;\n/** @type {?} */\nvar Event = win['Event'];\n/** @type {?} */\nvar MouseEvent = win['MouseEvent'];\n/** @type {?} */\nvar KeyboardEvent = win['KeyboardEvent'];\n/** @type {?} */\nvar EventTarget = win['EventTarget'];\n/** @type {?} */\nvar History = win['History'];\n/** @type {?} */\nvar Location = win['Location'];\n/** @type {?} */\nvar EventListener = win['EventListener'];\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * @return {?}\n */\nfunction isBs3() {\n    return win.__theme === 'bs4';\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\nvar BsDropdownDirective = /*@__PURE__*/ (function () {\n    /**\n     * @param {?} _elementRef\n     * @param {?} _renderer\n     * @param {?} _viewContainerRef\n     * @param {?} _cis\n     * @param {?} _config\n     * @param {?} _state\n     */\n    function BsDropdownDirective(_elementRef, _renderer, _viewContainerRef, _cis, _config, _state) {\n        this._elementRef = _elementRef;\n        this._renderer = _renderer;\n        this._viewContainerRef = _viewContainerRef;\n        this._cis = _cis;\n        this._config = _config;\n        this._state = _state;\n        // todo: move to component loader\n        this._isInlineOpen = false;\n        this._subscriptions = [];\n        this._isInited = false;\n        // create dropdown component loader\n        this._dropdown = this._cis\n            .createLoader(this._elementRef, this._viewContainerRef, this._renderer)\n            .provide({ provide: BsDropdownState, useValue: this._state });\n        this.onShown = this._dropdown.onShown;\n        this.shown = this._dropdown.shown;\n        this.onHidden = this._dropdown.onHidden;\n        this.hidden = this._dropdown.hidden;\n        this.isOpenChange = this._state.isOpenChange;\n        // set initial dropdown state from config\n        this._state.autoClose = this._config.autoClose;\n    }\n    Object.defineProperty(BsDropdownDirective.prototype, \"autoClose\", {\n        /**\n         * @return {?}\n         */\n        get: function () {\n            return this._state.autoClose;\n        },\n        /**\n         * Indicates that dropdown will be closed on item or document click,\n         * and after pressing ESC\n         * @param {?} value\n         * @return {?}\n         */\n        set: function (value) {\n            if (typeof value === 'boolean') {\n                this._state.autoClose = value;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(BsDropdownDirective.prototype, \"isDisabled\", {\n        /**\n         * @return {?}\n         */\n        get: function () { return this._isDisabled; },\n        /**\n         * Disables dropdown toggle and hides dropdown menu if opened\n         * @param {?} value\n         * @return {?}\n         */\n        set: function (value) {\n            this._isDisabled = value;\n            this._state.isDisabledChange.emit(value);\n            if (value) {\n                this.hide();\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(BsDropdownDirective.prototype, \"isOpen\", {\n        /**\n         * Returns whether or not the popover is currently being shown\n         * @return {?}\n         */\n        get: function () {\n            if (this._showInline) {\n                return this._isInlineOpen;\n            }\n            return this._dropdown.isShown;\n        },\n        /**\n         * @param {?} value\n         * @return {?}\n         */\n        set: function (value) {\n            if (value) {\n                this.show();\n            }\n            else {\n                this.hide();\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(BsDropdownDirective.prototype, \"isBs4\", {\n        /**\n         * @return {?}\n         */\n        get: function () {\n            return !isBs3();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    BsDropdownDirective.prototype.ngOnInit = function () {\n        var _this = this;\n        // fix: seems there are an issue with `routerLinkActive`\n        // which result in duplicated call ngOnInit without call to ngOnDestroy\n        // read more: https://github.com/valor-software/ngx-bootstrap/issues/1885\n        if (this._isInited) {\n            return;\n        }\n        this._isInited = true;\n        this._showInline = !this.container;\n        // attach DOM listeners\n        this._dropdown.listen({\n            triggers: this.triggers,\n            show: function () { return _this.show(); }\n        });\n        // toggle visibility on toggle element click\n        this._subscriptions.push(this._state\n            .toggleClick.subscribe(function (value) { return _this.toggle(value); }));\n        // hide dropdown if set disabled while opened\n        this._subscriptions.push(this._state\n            .isDisabledChange\n            .subscribe(function (element) {\n            if (element === true) {\n                _this.hide();\n            }\n        }));\n        // attach dropdown menu inside of dropdown\n        if (this._showInline) {\n            this._state.dropdownMenu\n                .then(function (dropdownMenu) {\n                _this._inlinedMenu = dropdownMenu.viewContainer.createEmbeddedView(dropdownMenu.templateRef);\n            });\n        }\n    };\n    /**\n     * Opens an elements popover. This is considered a manual triggering of\n     * the popover.\n     * @return {?}\n     */\n    BsDropdownDirective.prototype.show = function () {\n        var _this = this;\n        if (this.isOpen || this.isDisabled) {\n            return;\n        }\n        /** @type {?} */\n        var container = this._elementRef.nativeElement.lastElementChild;\n        setTimeout(function () { container.classList.add('fadeInDropdown'); }, 200);\n        if (this._showInline) {\n            this._isInlineOpen = true;\n            this.onShown.emit(true);\n            this.shown.emit(true);\n            this._state.isOpenChange.emit(true);\n            return;\n        }\n        this._state.dropdownMenu\n            .then(function (dropdownMenu) {\n            /** @type {?} */\n            var _dropup = _this.dropup === true ||\n                (typeof _this.dropup !== 'undefined' && _this.dropup !== false);\n            _this._state.direction = _dropup ? 'up' : 'down';\n            /** @type {?} */\n            var _placement = _this.placement ||\n                (_dropup ? 'top left' : 'bottom left');\n            // show dropdown\n            _this._dropdown\n                .attach(BsDropdownContainerComponent)\n                .to(_this.container)\n                .position({ attachment: _placement })\n                .show({\n                content: dropdownMenu.templateRef,\n                placement: _placement\n            });\n            _this._state.isOpenChange.emit(true);\n        });\n    };\n    /**\n     * Closes an elements popover. This is considered a manual triggering of\n     * the popover.\n     * @return {?}\n     */\n    BsDropdownDirective.prototype.hide = function () {\n        var _this = this;\n        if (!this.isOpen) {\n            return;\n        }\n        /** @type {?} */\n        var parent = this._elementRef.nativeElement.classList;\n        /** @type {?} */\n        var container = this._elementRef.nativeElement.lastElementChild;\n        if ((parent.value === 'dropdown open show') || (parent.value === 'btn-group dropup open show')) {\n            container.classList.remove('fadeInDropdown');\n            setTimeout(function () {\n                if (_this._showInline) {\n                    _this._isInlineOpen = false;\n                    _this.onHidden.emit(true);\n                    _this.hidden.emit(true);\n                }\n                else {\n                    _this._dropdown.hide();\n                }\n                _this._state.isOpenChange.emit(false);\n            }, 560);\n        }\n        else {\n            if (this._showInline) {\n                this._isInlineOpen = false;\n                this.onHidden.emit(true);\n                this.hidden.emit(true);\n            }\n            else {\n                this._dropdown.hide();\n            }\n            this._state.isOpenChange.emit(false);\n        }\n    };\n    /**\n     * Toggles an elements popover. This is considered a manual triggering of\n     * the popover.\n     * @param {?=} value\n     * @return {?}\n     */\n    BsDropdownDirective.prototype.toggle = function (value) {\n        if (this.isOpen || value === false) {\n            return this.hide();\n        }\n        return this.show();\n    };\n    /**\n     * @return {?}\n     */\n    BsDropdownDirective.prototype.ngOnDestroy = function () {\n        // clean up subscriptions and destroy dropdown\n        for (var _i = 0, _a = this._subscriptions; _i < _a.length; _i++) {\n            var sub = _a[_i];\n            sub.unsubscribe();\n        }\n        this._dropdown.dispose();\n    };\n    return BsDropdownDirective;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\nvar DropdownModule = /*@__PURE__*/ (function () {\n    function DropdownModule() {\n    }\n    /**\n     * @param {?=} config\n     * @return {?}\n     */\n    DropdownModule.forRoot = function (config) {\n        return {\n            ngModule: DropdownModule, providers: [\n                ComponentLoaderFactory,\n                PositioningService,\n                BsDropdownState,\n                { provide: BsDropdownConfig, useValue: config ? config : { autoClose: true } }\n            ]\n        };\n    };\n    return DropdownModule;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * @template T\n */\nvar LinkedList = /*@__PURE__*/ (function () {\n    function LinkedList() {\n        this.length = 0;\n        this.asArray = [];\n    }\n    /**\n     * @param {?} position\n     * @return {?}\n     */\n    LinkedList.prototype.getNode = function (position) {\n        if (this.length === 0 || position < 0 || position >= this.length) {\n            throw new Error('Position is out of the list');\n        }\n        /** @type {?} */\n        var current = this.head;\n        for (var index = 0; index < position; index++) {\n            current = current.next;\n        }\n        return current;\n    };\n    /**\n     * @return {?}\n     */\n    LinkedList.prototype.createInternalArrayRepresentation = function () {\n        /** @type {?} */\n        var outArray = [];\n        /** @type {?} */\n        var current = this.head;\n        while (current) {\n            outArray.push(current.value);\n            current = current.next;\n        }\n        this.asArray = outArray;\n    };\n    /**\n     * @param {?} position\n     * @return {?}\n     */\n    LinkedList.prototype.get = function (position) {\n        if (this.length === 0 || position < 0 || position >= this.length) {\n            return void 0;\n        }\n        /** @type {?} */\n        var current = this.head;\n        for (var index = 0; index < position; index++) {\n            current = current.next;\n        }\n        return current.value;\n    };\n    /**\n     * @param {?} value\n     * @param {?=} position\n     * @return {?}\n     */\n    LinkedList.prototype.add = function (value, position) {\n        if (position === void 0) {\n            position = this.length;\n        }\n        if (position < 0 || position > this.length) {\n            throw new Error('Position is out of the list');\n        }\n        /** @type {?} */\n        var node = {\n            value: /** @type {?} */ (value),\n            next: /** @type {?} */ (undefined),\n            previous: /** @type {?} */ (undefined)\n        };\n        if (this.length === 0) {\n            this.head = node;\n            this.tail = node;\n            this.current = node;\n        }\n        else {\n            if (position === 0) {\n                // first node\n                node.next = this.head;\n                this.head.previous = node;\n                this.head = node;\n            }\n            else if (position === this.length) {\n                // last node\n                this.tail.next = node;\n                node.previous = this.tail;\n                this.tail = node;\n            }\n            else {\n                /** @type {?} */\n                var currentPreviousNode = this.getNode(position - 1);\n                /** @type {?} */\n                var currentNextNode = currentPreviousNode.next;\n                currentPreviousNode.next = node;\n                currentNextNode.previous = node;\n                node.previous = currentPreviousNode;\n                node.next = currentNextNode;\n            }\n        }\n        this.length++;\n        this.createInternalArrayRepresentation();\n    };\n    /**\n     * @param {?=} position\n     * @return {?}\n     */\n    LinkedList.prototype.remove = function (position) {\n        if (position === void 0) {\n            position = 0;\n        }\n        if (this.length === 0 || position < 0 || position >= this.length) {\n            throw new Error('Position is out of the list');\n        }\n        if (position === 0) {\n            // first node\n            this.head = this.head.next;\n            if (this.head) {\n                // there is no second node\n                this.head.previous = undefined;\n            }\n            else {\n                // there is no second node\n                this.tail = undefined;\n            }\n        }\n        else if (position === this.length - 1) {\n            // last node\n            this.tail = this.tail.previous;\n            this.tail.next = undefined;\n        }\n        else {\n            /** @type {?} */\n            var removedNode = this.getNode(position);\n            removedNode.next.previous = removedNode.previous;\n            removedNode.previous.next = removedNode.next;\n        }\n        this.length--;\n        this.createInternalArrayRepresentation();\n    };\n    /**\n     * @param {?} position\n     * @param {?} value\n     * @return {?}\n     */\n    LinkedList.prototype.set = function (position, value) {\n        if (this.length === 0 || position < 0 || position >= this.length) {\n            throw new Error('Position is out of the list');\n        }\n        /** @type {?} */\n        var node = this.getNode(position);\n        node.value = value;\n        this.createInternalArrayRepresentation();\n    };\n    /**\n     * @return {?}\n     */\n    LinkedList.prototype.toArray = function () {\n        return this.asArray;\n    };\n    /**\n     * @param {?} fn\n     * @return {?}\n     */\n    LinkedList.prototype.findAll = function (fn) {\n        /** @type {?} */\n        var current = this.head;\n        /** @type {?} */\n        var result = [];\n        for (var index = 0; index < this.length; index++) {\n            if (fn(current.value, index)) {\n                result.push({ index: index, value: current.value });\n            }\n            current = current.next;\n        }\n        return result;\n    };\n    /**\n     * @param {...?} args\n     * @return {?}\n     */\n    LinkedList.prototype.push = function () {\n        var _this = this;\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        args.forEach(function (arg) {\n            _this.add(arg);\n        });\n        return this.length;\n    };\n    /**\n     * @return {?}\n     */\n    LinkedList.prototype.pop = function () {\n        if (this.length === 0) {\n            return undefined;\n        }\n        /** @type {?} */\n        var last = this.tail;\n        this.remove(this.length - 1);\n        return last.value;\n    };\n    /**\n     * @param {...?} args\n     * @return {?}\n     */\n    LinkedList.prototype.unshift = function () {\n        var _this = this;\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        args.reverse();\n        args.forEach(function (arg) {\n            _this.add(arg, 0);\n        });\n        return this.length;\n    };\n    /**\n     * @return {?}\n     */\n    LinkedList.prototype.shift = function () {\n        if (this.length === 0) {\n            return undefined;\n        }\n        /** @type {?} */\n        var lastItem = this.head.value;\n        this.remove();\n        return lastItem;\n    };\n    /**\n     * @param {?} fn\n     * @return {?}\n     */\n    LinkedList.prototype.forEach = function (fn) {\n        /** @type {?} */\n        var current = this.head;\n        for (var index = 0; index < this.length; index++) {\n            fn(current.value, index);\n            current = current.next;\n        }\n    };\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    LinkedList.prototype.indexOf = function (value) {\n        /** @type {?} */\n        var current = this.head;\n        /** @type {?} */\n        var position = 0;\n        for (var index = 0; index < this.length; index++) {\n            if (current.value === value) {\n                position = index;\n                break;\n            }\n            current = current.next;\n        }\n        return position;\n    };\n    /**\n     * @param {?} fn\n     * @return {?}\n     */\n    LinkedList.prototype.some = function (fn) {\n        /** @type {?} */\n        var current = this.head;\n        /** @type {?} */\n        var result = false;\n        while (current && !result) {\n            if (fn(current.value)) {\n                result = true;\n                break;\n            }\n            current = current.next;\n        }\n        return result;\n    };\n    /**\n     * @param {?} fn\n     * @return {?}\n     */\n    LinkedList.prototype.every = function (fn) {\n        /** @type {?} */\n        var current = this.head;\n        /** @type {?} */\n        var result = true;\n        while (current && result) {\n            if (!fn(current.value)) {\n                result = false;\n            }\n            current = current.next;\n        }\n        return result;\n    };\n    /**\n     * @return {?}\n     */\n    LinkedList.prototype.toString = function () {\n        return '[Linked List]';\n    };\n    /**\n     * @param {?} fn\n     * @return {?}\n     */\n    LinkedList.prototype.find = function (fn) {\n        /** @type {?} */\n        var current = this.head;\n        /** @type {?} */\n        var result;\n        for (var index = 0; index < this.length; index++) {\n            if (fn(current.value, index)) {\n                result = current.value;\n                break;\n            }\n            current = current.next;\n        }\n        return result;\n    };\n    /**\n     * @param {?} fn\n     * @return {?}\n     */\n    LinkedList.prototype.findIndex = function (fn) {\n        /** @type {?} */\n        var current = this.head;\n        /** @type {?} */\n        var result;\n        for (var index = 0; index < this.length; index++) {\n            if (fn(current.value, index)) {\n                result = index;\n                break;\n            }\n            current = current.next;\n        }\n        return result;\n    };\n    return LinkedList;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\nvar CarouselConfig = /*@__PURE__*/ (function () {\n    function CarouselConfig() {\n        /**\n         * Default interval of auto changing of slides\n         */\n        this.interval = 5000;\n        /**\n         * Is loop of auto changing of slides can be paused\n         */\n        this.noPause = false;\n        /**\n         * Is slides can wrap from the last to the first slide\n         */\n        this.noWrap = false;\n        this.keyboard = false;\n    }\n    return CarouselConfig;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/** @enum {number} */\nvar Direction = /*@__PURE__*/ (function () {\n    var Direction = {\n        UNKNOWN: 0, NEXT: 1, PREV: 2,\n    };\n    Direction[Direction.UNKNOWN] = 'UNKNOWN';\n    Direction[Direction.NEXT] = 'NEXT';\n    Direction[Direction.PREV] = 'PREV';\n    return Direction;\n}());\n/**\n * Base element to create carousel\n */\nvar CarouselComponent = /*@__PURE__*/ (function () {\n    /**\n     * @param {?} config\n     * @param {?} el\n     * @param {?} platformId\n     */\n    function CarouselComponent(config, el, platformId) {\n        this.SWIPE_ACTION = { LEFT: 'swipeleft', RIGHT: 'swiperight' };\n        this._slides = new LinkedList();\n        this.destroyed = false;\n        // protected el: ElementRef = null;\n        this.el = null;\n        this.animationEnd = true;\n        this.isBrowser = false;\n        this.isControls = true;\n        this.class = '';\n        this.type = '';\n        this.animation = '';\n        /**\n         * Will be emitted when active slide has been changed. Part of two-way-bindable [(activeSlide)] property\n         */\n        this.activeSlideChange = new EventEmitter(false);\n        this.isBrowser = isPlatformBrowser(platformId);\n        Object.assign(this, config);\n        this.el = el;\n    }\n    Object.defineProperty(CarouselComponent.prototype, \"slides\", {\n        /**\n         * @return {?}\n         */\n        get: function () {\n            return this._slides.toArray();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CarouselComponent.prototype, \"activeSlide\", {\n        /**\n         * @return {?}\n         */\n        get: function () {\n            return this._currentActiveSlide;\n        },\n        /**\n         * Index of currently displayed slide(started for 0)\n         * @param {?} index\n         * @return {?}\n         */\n        set: function (index) {\n            if (this._slides.length && index !== this._currentActiveSlide) {\n                this._select(index);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    CarouselComponent.prototype.checkNavigation = function () {\n        if (this.type === 'carousel-multi-item') {\n            return false;\n        }\n        return true;\n    };\n    /**\n     * @return {?}\n     */\n    CarouselComponent.prototype.checkDots = function () {\n        if (this.type === 'carousel-thumbnails') {\n            return false;\n        }\n        return true;\n    };\n    /**\n     * @param {?} slide\n     * @return {?}\n     */\n    CarouselComponent.prototype.getImg = function (slide) {\n        return slide.el.nativeElement.querySelector('img').src;\n    };\n    Object.defineProperty(CarouselComponent.prototype, \"interval\", {\n        /**\n         * Delay of item cycling in milliseconds. If false, carousel won't cycle automatically.\n         * @return {?}\n         */\n        get: function () {\n            return this._interval;\n        },\n        /**\n         * @param {?} value\n         * @return {?}\n         */\n        set: function (value) {\n            this._interval = value;\n            this.restartTimer();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CarouselComponent.prototype, \"isBs4\", {\n        /**\n         * @return {?}\n         */\n        get: function () {\n            return !isBs3();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    CarouselComponent.prototype.ngOnDestroy = function () {\n        this.destroyed = true;\n    };\n    /**\n     * Adds new slide. If this slide is first in collection - set it as active and starts auto changing\n     * @param {?} slide\n     * @return {?}\n     */\n    CarouselComponent.prototype.addSlide = function (slide) {\n        this._slides.add(slide);\n        if (this._slides.length === 1) {\n            this._currentActiveSlide = void 0;\n            this.activeSlide = 0;\n            this.play();\n        }\n    };\n    /**\n     * @return {?}\n     */\n    CarouselComponent.prototype.ngAfterViewInit = function () {\n        var _this = this;\n        // Setting first visible slide\n        if (this.activeSlideIndex) {\n            setTimeout(function () {\n                _this._select(_this.activeSlideIndex);\n                _this.activeSlideChange.emit({ 'relatedTarget': _this.activeSlide });\n            }, 0);\n        }\n    };\n    /**\n     * Removes specified slide. If this slide is active - will roll to another slide\n     * @param {?} slide\n     * @return {?}\n     */\n    CarouselComponent.prototype.removeSlide = function (slide) {\n        var _this = this;\n        /** @type {?} */\n        var remIndex = this._slides.indexOf(slide);\n        if (this._currentActiveSlide === remIndex) {\n            /** @type {?} */\n            var nextSlideIndex_1 = void 0;\n            if (this._slides.length > 1) {\n                // if this slide last - will roll to first slide, if noWrap flag is FALSE or to previous, if noWrap is TRUE\n                // in case, if this slide in middle of collection, index of next slide is same to removed\n                nextSlideIndex_1 = !this.isLast(remIndex) ? remIndex :\n                    this.noWrap ? remIndex - 1 : 0;\n            }\n            this._slides.remove(remIndex);\n            // prevents exception with changing some value after checking\n            setTimeout(function () {\n                _this._select(nextSlideIndex_1);\n            }, 0);\n        }\n        else {\n            this._slides.remove(remIndex);\n            /** @type {?} */\n            var currentSlideIndex_1 = this.getCurrentSlideIndex();\n            setTimeout(function () {\n                // after removing, need to actualize index of current active slide\n                _this._currentActiveSlide = currentSlideIndex_1;\n                _this.activeSlideChange.emit(_this._currentActiveSlide);\n            }, 0);\n        }\n    };\n    /**\n     * @param {?=} action\n     * @return {?}\n     */\n    CarouselComponent.prototype.swipe = function (action) {\n        if (action === void 0) {\n            action = this.SWIPE_ACTION.RIGHT;\n        }\n        if (action === this.SWIPE_ACTION.RIGHT) {\n            this.previousSlide();\n        }\n        if (action === this.SWIPE_ACTION.LEFT) {\n            this.nextSlide();\n        }\n    };\n    /**\n     * Rolling to next slide\n     * @param {?=} force\n     * @return {?}\n     */\n    CarouselComponent.prototype.nextSlide = function (force) {\n        if (force === void 0) {\n            force = false;\n        }\n        if (this.animation === 'slide') {\n            this.pause();\n            /** @type {?} */\n            var direction = Direction.NEXT;\n            this.slideAnimation(this.findNextSlideIndex(direction, force), direction);\n        }\n        else if (this.animation === 'fade') {\n            this.pause();\n            this.fadeAnimation(this.findNextSlideIndex(Direction.NEXT, force));\n        }\n        else {\n            this.activeSlide = this.findNextSlideIndex(Direction.NEXT, force);\n        }\n        if (!this.animation) {\n            this.activeSlideChange.emit({ 'direction': 'Next', 'relatedTarget': this.activeSlide });\n        }\n    };\n    /**\n     * Rolling to previous slide\n     * @param {?=} force\n     * @return {?}\n     */\n    CarouselComponent.prototype.previousSlide = function (force) {\n        if (force === void 0) {\n            force = false;\n        }\n        if (this.animation === 'slide') {\n            this.pause();\n            /** @type {?} */\n            var direction = Direction.PREV;\n            this.slideAnimation(this.findNextSlideIndex(direction, force), direction);\n        }\n        else if (this.animation === 'fade') {\n            this.pause();\n            this.fadeAnimation(this.findNextSlideIndex(Direction.PREV, force));\n        }\n        else {\n            this.activeSlide = this.findNextSlideIndex(Direction.PREV, force);\n        }\n        if (!this.animation) {\n            this.activeSlideChange.emit({ 'direction': 'Prev', 'relatedTarget': this.activeSlide });\n        }\n    };\n    /**\n     * @param {?} goToIndex\n     * @return {?}\n     */\n    CarouselComponent.prototype.fadeAnimation = function (goToIndex) {\n        var _this = this;\n        /** @type {?} */\n        var goToSlide = this._slides.get(goToIndex);\n        if (this.animationEnd) {\n            this.animationEnd = false;\n            goToSlide.directionNext = true;\n            if (this.isBrowser) {\n                setTimeout(function () {\n                    goToSlide.directionNext = false;\n                    _this.animationEnd = true;\n                    _this.activeSlide = goToIndex;\n                    _this.activeSlideChange.emit({ 'direction': 'Next', 'relatedTarget': _this.activeSlide });\n                    _this.play();\n                }, 100);\n            }\n        }\n    };\n    /**\n     * @param {?} goToIndex\n     * @param {?} direction\n     * @return {?}\n     */\n    CarouselComponent.prototype.slideAnimation = function (goToIndex, direction) {\n        var _this = this;\n        /** @type {?} */\n        var currentSlide = this._slides.get(this._currentActiveSlide);\n        /** @type {?} */\n        var goToSlide = this._slides.get(goToIndex);\n        if (this.animationEnd) {\n            if (direction === Direction.NEXT) {\n                this.animationEnd = false;\n                goToSlide.directionNext = true;\n                if (this.isBrowser) {\n                    setTimeout(function () {\n                        goToSlide.directionLeft = true;\n                        currentSlide.directionLeft = true;\n                    }, 100);\n                }\n            }\n            if (direction === Direction.PREV) {\n                this.animationEnd = false;\n                goToSlide.directionPrev = true;\n                if (this.isBrowser) {\n                    setTimeout(function () {\n                        goToSlide.directionRight = true;\n                        currentSlide.directionRight = true;\n                    }, 100);\n                }\n            }\n            if (this.isBrowser) {\n                setTimeout(function () {\n                    goToSlide.directionLeft = false;\n                    goToSlide.directionNext = false;\n                    currentSlide.directionLeft = false;\n                    currentSlide.directionNext = false;\n                    goToSlide.directionRight = false;\n                    goToSlide.directionPrev = false;\n                    currentSlide.directionRight = false;\n                    currentSlide.directionPrev = false;\n                    _this.animationEnd = true;\n                    _this.activeSlide = goToIndex;\n                    /** @type {?} */\n                    var directionName;\n                    if (direction === Direction.NEXT) {\n                        directionName = 'Next';\n                    }\n                    else if (direction === Direction.PREV) {\n                        directionName = 'Prev';\n                    }\n                    _this.activeSlideChange.emit({ 'direction': directionName, 'relatedTarget': _this.activeSlide });\n                    _this.play();\n                }, 700);\n            }\n        }\n    };\n    /**\n     * Rolling to specified slide\n     * @param {?} index\n     * @return {?}\n     */\n    CarouselComponent.prototype.selectSlide = function (index) {\n        this.pause();\n        if (this.animation === 'slide') {\n            if (this.activeSlide < index) {\n                this.slideAnimation(index, Direction.NEXT);\n            }\n            else if (this.activeSlide > index) {\n                this.slideAnimation(index, Direction.PREV);\n            }\n        }\n        else if (this.animation === 'fade') {\n            if (index !== this.activeSlide) {\n                this.fadeAnimation(index);\n            }\n        }\n        this.play();\n    };\n    /**\n     * Starts a auto changing of slides\n     * @return {?}\n     */\n    CarouselComponent.prototype.play = function () {\n        if (!this.isPlaying) {\n            this.isPlaying = true;\n            this.restartTimer();\n        }\n    };\n    /**\n     * Stops a auto changing of slides\n     * @return {?}\n     */\n    CarouselComponent.prototype.pause = function () {\n        if (!this.noPause) {\n            this.isPlaying = false;\n            this.resetTimer();\n        }\n    };\n    /**\n     * Finds and returns index of currently displayed slide\n     * @return {?}\n     */\n    CarouselComponent.prototype.getCurrentSlideIndex = function () {\n        return this._slides.findIndex(function (slide) { return slide.active; });\n    };\n    /**\n     * Defines, whether the specified index is last in collection\n     * @param {?} index\n     * @return {?}\n     */\n    CarouselComponent.prototype.isLast = function (index) {\n        return index + 1 >= this._slides.length;\n    };\n    /**\n     * Defines next slide index, depending of direction\n     * @param {?} direction\n     * @param {?} force\n     * @return {?}\n     */\n    CarouselComponent.prototype.findNextSlideIndex = function (direction, force) {\n        /** @type {?} */\n        var nextSlideIndex = 0;\n        if (!force && (this.isLast(this.activeSlide) && direction !== Direction.PREV && this.noWrap)) {\n            return void 0;\n        }\n        switch (direction) {\n            case Direction.NEXT:\n                // if this is last slide, not force, looping is disabled and need to going forward - select current slide, as a next\n                nextSlideIndex = (!this.isLast(this._currentActiveSlide)) ? this._currentActiveSlide + 1 :\n                    (!force && this.noWrap) ? this._currentActiveSlide : 0;\n                break;\n            case Direction.PREV:\n                // if this is first slide, not force, looping is disabled and need to going backward - select current slide, as a next\n                nextSlideIndex = (this._currentActiveSlide > 0) ? this._currentActiveSlide - 1 :\n                    (!force && this.noWrap) ? this._currentActiveSlide : this._slides.length - 1;\n                break;\n            default:\n                throw new Error('Unknown direction');\n        }\n        return nextSlideIndex;\n    };\n    /**\n     * Sets a slide, which specified through index, as active\n     * @param {?} index\n     * @return {?}\n     */\n    CarouselComponent.prototype._select = function (index) {\n        if (isNaN(index)) {\n            this.pause();\n            return;\n        }\n        /** @type {?} */\n        var currentSlide = this._slides.get(this._currentActiveSlide);\n        if (currentSlide) {\n            currentSlide.active = false;\n        }\n        /** @type {?} */\n        var nextSlide = this._slides.get(index);\n        if (nextSlide) {\n            this._currentActiveSlide = index;\n            nextSlide.active = true;\n            this.activeSlide = index;\n            // this.activeSlideChange.emit(index);\n        }\n    };\n    /**\n     * Starts loop of auto changing of slides\n     * @return {?}\n     */\n    CarouselComponent.prototype.restartTimer = function () {\n        var _this = this;\n        this.resetTimer();\n        if (this.isBrowser) {\n            /** @type {?} */\n            var interval = +this.interval;\n            if (!isNaN(interval) && interval > 0) {\n                this.currentInterval = setInterval(function () {\n                    /** @type {?} */\n                    var nInterval = +_this.interval;\n                    if (_this.isPlaying && !isNaN(_this.interval) && nInterval > 0 && _this.slides.length) {\n                        _this.nextSlide();\n                    }\n                    else {\n                        _this.pause();\n                    }\n                }, interval);\n            }\n        }\n    };\n    /**\n     * Stops loop of auto changing of slides\n     * @return {?}\n     */\n    CarouselComponent.prototype.resetTimer = function () {\n        if (this.isBrowser) {\n            if (this.currentInterval) {\n                clearInterval(this.currentInterval);\n                this.currentInterval = void 0;\n            }\n        }\n    };\n    /**\n     * @param {?} el\n     * @param {?} className\n     * @return {?}\n     */\n    CarouselComponent.prototype.hasClass = function (el, className) {\n        if (el.classList) {\n            return el.classList.contains(className);\n        }\n        else {\n            return !!el.className.match(new RegExp('(\\\\s|^)' + className + '(\\\\s|$)'));\n        }\n    };\n    /**\n     * @param {?} el\n     * @param {?} className\n     * @return {?}\n     */\n    CarouselComponent.prototype.classAdd = function (el, className) {\n        if (el.classList) {\n            el.classList.add(className);\n        }\n        else if (!this.hasClass(el, className)) {\n            el.className += ' ' + className;\n        }\n    };\n    /**\n     * @param {?} el\n     * @param {?} className\n     * @return {?}\n     */\n    CarouselComponent.prototype.removeClass = function (el, className) {\n        if (el.classList) {\n            el.classList.remove(className);\n        }\n        else if (this.hasClass(el, className)) {\n            /** @type {?} */\n            var reg = new RegExp('(\\\\s|^)' + className + '(\\\\s|$)');\n            el.className = el.className.replace(reg, ' ');\n        }\n    };\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n    CarouselComponent.prototype.keyboardControl = function (event) {\n        if (this.keyboard) {\n            if (event.keyCode === 39) {\n                this.nextSlide();\n            }\n            if (event.keyCode === 37) {\n                this.previousSlide();\n            }\n        }\n    };\n    /**\n     * @return {?}\n     */\n    CarouselComponent.prototype.focus = function () {\n        this.el.nativeElement.focus();\n    };\n    return CarouselComponent;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\nvar SlideComponent = /*@__PURE__*/ (function () {\n    /**\n     * @param {?} carousel\n     * @param {?} el\n     */\n    function SlideComponent(carousel, el) {\n        this.carousel = carousel;\n        this.animated = false;\n        this.directionNext = false;\n        this.directionLeft = false;\n        this.directionPrev = false;\n        this.directionRight = false;\n        /**\n         * Wraps element by appropriate CSS classes\n         */\n        this.el = null;\n        // this.carousel = carousel;\n        this.el = el;\n    }\n    /**\n     * Fires changes in container collection after adding a new slide instance\n     * @return {?}\n     */\n    SlideComponent.prototype.ngOnInit = function () {\n        this.carousel.addSlide(this);\n    };\n    /**\n     * Fires changes in container collection after removing of this slide instance\n     * @return {?}\n     */\n    SlideComponent.prototype.ngOnDestroy = function () {\n        this.carousel.removeSlide(this);\n    };\n    return SlideComponent;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\nvar CarouselModule = /*@__PURE__*/ (function () {\n    function CarouselModule() {\n    }\n    /**\n     * @return {?}\n     */\n    CarouselModule.forRoot = function () {\n        return { ngModule: CarouselModule, providers: [] };\n    };\n    return CarouselModule;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\nvar BaseChartDirective = /*@__PURE__*/ (function () {\n    /**\n     * @param {?} element\n     * @param {?} platformId\n     */\n    function BaseChartDirective(element, platformId) {\n        this.labels = [];\n        this.options = {\n            legend: { display: false }\n        };\n        this.legend = false;\n        this.chartClick = new EventEmitter();\n        this.chartHover = new EventEmitter();\n        this.initFlag = false;\n        this.isBrowser = false;\n        this.element = element;\n        this.isBrowser = isPlatformBrowser(platformId);\n    }\n    /**\n     * @return {?}\n     */\n    BaseChartDirective.prototype.ngOnInit = function () {\n        if (this.isBrowser) {\n            this.ctx = this.element.nativeElement.getContext('2d');\n            this.cvs = this.element.nativeElement;\n            this.initFlag = true;\n            if (this.data || this.datasets) {\n                this.refresh();\n            }\n        }\n    };\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n    BaseChartDirective.prototype.ngOnChanges = function (changes) {\n        if (this.initFlag) {\n            // Check if the changes are in the data or datasets\n            if ((changes.hasOwnProperty('data') || changes.hasOwnProperty('datasets')) && !changes.hasOwnProperty('labels')) {\n                if (changes['data']) {\n                    this.updateChartData(changes['data'].currentValue);\n                }\n                else {\n                    this.updateChartData(changes['datasets'].currentValue);\n                }\n                this.chart.update();\n            }\n            else {\n                // otherwise rebuild the chart\n                this.refresh();\n            }\n        }\n    };\n    /**\n     * @return {?}\n     */\n    BaseChartDirective.prototype.ngOnDestroy = function () {\n        if (this.chart) {\n            this.chart.destroy();\n            this.chart = void 0;\n        }\n    };\n    /**\n     * @param {?} ctx\n     * @return {?}\n     */\n    BaseChartDirective.prototype.getChartBuilder = function (ctx /*, data:Array<any>, options:any*/) {\n        var _this = this;\n        /** @type {?} */\n        var datasets = this.getDatasets();\n        /** @type {?} */\n        var options = Object.assign({}, this.options);\n        if (this.legend === false) {\n            options.legend = { display: false };\n        }\n        // hock for onHover and onClick events\n        options.hover = options.hover || {};\n        if (!options.hover.onHover) {\n            options.hover.onHover = function (event, active) {\n                if (active && active.length) {\n                    _this.chartHover.emit({ event: event, active: active });\n                }\n            };\n        }\n        if (!options.onClick) {\n            options.onClick = function (event, active) {\n                _this.chartClick.emit({ event: event, active: active });\n            };\n        }\n        /** @type {?} */\n        var opts = {\n            type: this.chartType,\n            data: {\n                labels: this.labels,\n                datasets: datasets\n            },\n            options: options\n        };\n        return new Chart(ctx, opts);\n    };\n    /**\n     * @param {?} newDataValues\n     * @return {?}\n     */\n    BaseChartDirective.prototype.updateChartData = function (newDataValues) {\n        if (Array.isArray(newDataValues[0].data)) {\n            this.chart.data.datasets.forEach(function (dataset, i) {\n                dataset.data = newDataValues[i].data;\n                if (newDataValues[i].label) {\n                    dataset.label = newDataValues[i].label;\n                }\n            });\n        }\n        else {\n            this.chart.data.datasets[0].data = newDataValues;\n        }\n    };\n    /**\n     * @return {?}\n     */\n    BaseChartDirective.prototype.getDatasets = function () {\n        var _this = this;\n        /** @type {?} */\n        var datasets = void 0;\n        // in case if datasets is not provided, but data is present\n        if (!this.datasets || !this.datasets.length && (this.data && this.data.length)) {\n            if (Array.isArray(this.data[0])) {\n                datasets = ((this.data)).map(function (data, index) {\n                    return { data: data, label: _this.labels[index] || \"Label \" + index };\n                });\n            }\n            else {\n                datasets = [{ data: this.data, label: \"Label 0\" }];\n            }\n        }\n        if (this.datasets && this.datasets.length ||\n            (datasets && datasets.length)) {\n            datasets = (this.datasets || datasets)\n                .map(function (elm, index) {\n                /** @type {?} */\n                var newElm = Object.assign({}, elm);\n                if (_this.colors && _this.colors.length) {\n                    Object.assign(newElm, _this.colors[index]);\n                }\n                else {\n                    Object.assign(newElm, getColors(_this.chartType, index, newElm.data.length));\n                }\n                return newElm;\n            });\n        }\n        if (!datasets) {\n            throw new Error(\"ng-charts configuration error,\\n      data or datasets field are required to render char \" + this.chartType);\n        }\n        return datasets;\n    };\n    /**\n     * @return {?}\n     */\n    BaseChartDirective.prototype.refresh = function () {\n        this.ngOnDestroy();\n        this.chart = this.getChartBuilder(this.ctx /*, data, this.options*/);\n    };\n    BaseChartDirective.defaultColors = [\n        [255, 99, 132],\n        [54, 162, 235],\n        [255, 206, 86],\n        [231, 233, 237],\n        [75, 192, 192],\n        [151, 187, 205],\n        [220, 220, 220],\n        [247, 70, 74],\n        [70, 191, 189],\n        [253, 180, 92],\n        [148, 159, 177],\n        [77, 83, 96]\n    ];\n    return BaseChartDirective;\n}());\n/**\n * @param {?} colour\n * @param {?} alpha\n * @return {?}\n */\nfunction rgba(colour, alpha) {\n    return 'rgba(' + colour.concat(alpha).join(',') + ')';\n}\n/**\n * @param {?} min\n * @param {?} max\n * @return {?}\n */\nfunction getRandomInt(min, max) {\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n}\n/**\n * @param {?} colors\n * @return {?}\n */\nfunction formatLineColor(colors) {\n    return {\n        backgroundColor: rgba(colors, 0.4),\n        borderColor: rgba(colors, 1),\n        pointBackgroundColor: rgba(colors, 1),\n        pointBorderColor: '#fff',\n        pointHoverBackgroundColor: '#fff',\n        pointHoverBorderColor: rgba(colors, 0.8)\n    };\n}\n/**\n * @param {?} colors\n * @return {?}\n */\nfunction formatBarColor(colors) {\n    return {\n        backgroundColor: rgba(colors, 0.6),\n        borderColor: rgba(colors, 1),\n        hoverBackgroundColor: rgba(colors, 0.8),\n        hoverBorderColor: rgba(colors, 1)\n    };\n}\n/**\n * @param {?} colors\n * @return {?}\n */\nfunction formatPieColors(colors) {\n    return {\n        backgroundColor: colors.map(function (color) { return rgba(color, 0.6); }),\n        borderColor: colors.map(function () { return '#fff'; }),\n        pointBackgroundColor: colors.map(function (color) { return rgba(color, 1); }),\n        pointBorderColor: colors.map(function () { return '#fff'; }),\n        pointHoverBackgroundColor: colors.map(function (color) { return rgba(color, 1); }),\n        pointHoverBorderColor: colors.map(function (color) { return rgba(color, 1); })\n    };\n}\n/**\n * @param {?} colors\n * @return {?}\n */\nfunction formatPolarAreaColors(colors) {\n    return {\n        backgroundColor: colors.map(function (color) { return rgba(color, 0.6); }),\n        borderColor: colors.map(function (color) { return rgba(color, 1); }),\n        hoverBackgroundColor: colors.map(function (color) { return rgba(color, 0.8); }),\n        hoverBorderColor: colors.map(function (color) { return rgba(color, 1); })\n    };\n}\n/**\n * @return {?}\n */\nfunction getRandomColor() {\n    return [getRandomInt(0, 255), getRandomInt(0, 255), getRandomInt(0, 255)];\n}\n/**\n * Generate colors for line|bar charts\n * @param {?} index\n * @return {?}\n */\nfunction generateColor(index) {\n    return BaseChartDirective.defaultColors[index] || getRandomColor();\n}\n/**\n * Generate colors for pie|doughnut charts\n * @param {?} count\n * @return {?}\n */\nfunction generateColors(count) {\n    /** @type {?} */\n    var colorsArr = new Array(count);\n    for (var i = 0; i < count; i++) {\n        colorsArr[i] = BaseChartDirective.defaultColors[i] || getRandomColor();\n    }\n    return colorsArr;\n}\n/**\n * Generate colors by chart type\n * @param {?} chartType\n * @param {?} index\n * @param {?} count\n * @return {?}\n */\nfunction getColors(chartType, index, count) {\n    if (chartType === 'pie' || chartType === 'doughnut') {\n        return formatPieColors(generateColors(count));\n    }\n    if (chartType === 'polarArea') {\n        return formatPolarAreaColors(generateColors(count));\n    }\n    if (chartType === 'line' || chartType === 'radar') {\n        return formatLineColor(generateColor(index));\n    }\n    if (chartType === 'bar' || chartType === 'horizontalBar') {\n        return formatBarColor(generateColor(index));\n    }\n    return generateColor(index);\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\nvar ChartsModule = /*@__PURE__*/ (function () {\n    function ChartsModule() {\n    }\n    return ChartsModule;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\nvar CollapseComponent = /*@__PURE__*/ (function () {\n    function CollapseComponent() {\n        this.isCollapsed = true;\n        this.showBsCollapse = new EventEmitter();\n        this.shownBsCollapse = new EventEmitter();\n        this.hideBsCollapse = new EventEmitter();\n        this.hiddenBsCollapse = new EventEmitter();\n        this.collapsed = new EventEmitter();\n        this.expanded = new EventEmitter();\n        this.overflow = 'hidden';\n    }\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n    CollapseComponent.prototype.onExpandBodyDone = function (event) {\n        if (event.toState === 'expanded') {\n            this.shownBsCollapse.emit(this);\n            this.expanded.emit(this);\n        }\n        else {\n            this.hiddenBsCollapse.emit(this);\n            this.collapsed.emit(this);\n        }\n    };\n    /**\n     * @return {?}\n     */\n    CollapseComponent.prototype.toggle = function () {\n        this.isCollapsed ? this.show() : this.hide();\n    };\n    /**\n     * @return {?}\n     */\n    CollapseComponent.prototype.show = function () {\n        this.expandAnimationState = 'expanded';\n        this.isCollapsed = false;\n        this.showBsCollapse.emit(this);\n    };\n    /**\n     * @return {?}\n     */\n    CollapseComponent.prototype.hide = function () {\n        this.expandAnimationState = 'collapsed';\n        this.isCollapsed = true;\n        this.hideBsCollapse.emit(this);\n    };\n    /**\n     * @return {?}\n     */\n    CollapseComponent.prototype.initializeCollapseState = function () {\n        this.isCollapsed ? this.hide() : this.show();\n    };\n    /**\n     * @return {?}\n     */\n    CollapseComponent.prototype.ngOnInit = function () {\n        this.initializeCollapseState();\n    };\n    return CollapseComponent;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\nvar CollapseModule = /*@__PURE__*/ (function () {\n    function CollapseModule() {\n    }\n    /**\n     * @return {?}\n     */\n    CollapseModule.forRoot = function () {\n        return { ngModule: CollapseModule, providers: [] };\n    };\n    return CollapseModule;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\nvar ModalOptions = /*@__PURE__*/ (function () {\n    function ModalOptions() {\n    }\n    return ModalOptions;\n}());\nvar MDBModalRef = /*@__PURE__*/ (function () {\n    function MDBModalRef() {\n    }\n    /**\n     * Hides the modal\n     * @return {?}\n     */\n    MDBModalRef.prototype.hide = function () { };\n    return MDBModalRef;\n}());\n/** @type {?} */\nvar modalConfigDefaults = {\n    backdrop: true,\n    keyboard: true,\n    focus: true,\n    show: false,\n    ignoreBackdropClick: false,\n    class: '',\n    animated: true\n};\n/** @type {?} */\nvar ClassName = {\n    SCROLLBAR_MEASURER: 'modal-scrollbar-measure',\n    BACKDROP: 'modal-backdrop',\n    OPEN: 'modal-open',\n    FADE: 'fade',\n    IN: 'in',\n    // bs3\n    SHOW: 'show' // bs4\n};\n/** @type {?} */\n/** @type {?} */\nvar TransitionDurations = {\n    MODAL: 300,\n    BACKDROP: 150\n};\n/** @type {?} */\nvar DISMISS_REASONS = {\n    BACKRDOP: 'backdrop-click',\n    ESC: 'esc'\n};\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\nvar Utils = /*@__PURE__*/ (function () {\n    function Utils() {\n    }\n    /**\n     * @param {?} element\n     * @return {?}\n     */\n    Utils.reflow = function (element) {\n        (function (bs) { return bs; })(element.offsetHeight);\n    };\n    /**\n     * @param {?} elem\n     * @return {?}\n     */\n    Utils.getStyles = function (elem) {\n        /** @type {?} */\n        var view = elem.ownerDocument.defaultView;\n        if (!view || !view.opener) {\n            view = win;\n        }\n        return view.getComputedStyle(elem);\n    };\n    return Utils;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\nvar ModalBackdropOptions = /*@__PURE__*/ (function () {\n    /**\n     * @param {?} options\n     */\n    function ModalBackdropOptions(options) {\n        this.animate = true;\n        Object.assign(this, options);\n    }\n    return ModalBackdropOptions;\n}());\n/**\n * This component will be added as background layout for modals if enabled\n */\nvar ModalBackdropComponent = /*@__PURE__*/ (function () {\n    /**\n     * @param {?} element\n     * @param {?} renderer\n     */\n    function ModalBackdropComponent(element, renderer) {\n        this.classNameBackDrop = true;\n        this._isShown = false;\n        this.element = element;\n        this.renderer = renderer;\n    }\n    Object.defineProperty(ModalBackdropComponent.prototype, \"isAnimated\", {\n        /**\n         * @return {?}\n         */\n        get: function () {\n            return this._isAnimated;\n        },\n        /**\n         * @param {?} value\n         * @return {?}\n         */\n        set: function (value) {\n            this._isAnimated = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ModalBackdropComponent.prototype, \"isShown\", {\n        /**\n         * @return {?}\n         */\n        get: function () {\n            return this._isShown;\n        },\n        /**\n         * @param {?} value\n         * @return {?}\n         */\n        set: function (value) {\n            this._isShown = value;\n            if (value) {\n                this.renderer.addClass(this.element.nativeElement, \"\" + ClassName.IN);\n                if (!isBs3()) {\n                    this.renderer.addClass(this.element.nativeElement, \"\" + ClassName.SHOW);\n                }\n            }\n            else {\n                this.renderer.removeClass(this.element.nativeElement, \"\" + ClassName.IN);\n                if (!isBs3()) {\n                    this.renderer.removeClass(this.element.nativeElement, \"\" + ClassName.SHOW);\n                }\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    ModalBackdropComponent.prototype.ngOnInit = function () {\n        if (this.isAnimated) {\n            this.renderer.addClass(this.element.nativeElement, \"\" + ClassName.FADE);\n            Utils.reflow(this.element.nativeElement);\n        }\n        else {\n            this.renderer.addClass(this.element.nativeElement, \"\" + ClassName.FADE);\n            Utils.reflow(this.element.nativeElement);\n        }\n        this.isShown = true;\n    };\n    return ModalBackdropComponent;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/** @type {?} */\nvar TRANSITION_DURATION = 300;\n/** @type {?} */\nvar BACKDROP_TRANSITION_DURATION = 150;\n/**\n * Mark any code with directive to show it's content in modal\n */\nvar ModalDirective = /*@__PURE__*/ (function () {\n    /**\n     * @param {?} _element\n     * @param {?} _viewContainerRef\n     * @param {?} _renderer\n     * @param {?} clf\n     */\n    function ModalDirective(_element, _viewContainerRef, _renderer, clf) {\n        /**\n         * This event fires immediately when the `show` instance method is called.\n         */\n        this.onShow = new EventEmitter();\n        this.open = new EventEmitter();\n        /**\n         * This event is fired when the modal has been made visible to the user (will wait for CSS transitions to complete)\n         */\n        this.onShown = new EventEmitter();\n        this.opened = new EventEmitter();\n        /**\n         * This event is fired immediately when the hide instance method has been called.\n         */\n        this.onHide = new EventEmitter();\n        this.close = new EventEmitter();\n        /**\n         * This event is fired when the modal has finished being hidden from the user (will wait for CSS transitions to complete).\n         */\n        this.onHidden = new EventEmitter();\n        this.closed = new EventEmitter();\n        this.isAnimated = true;\n        this._isShown = false;\n        this.isBodyOverflowing = false;\n        this.originalBodyPadding = 0;\n        this.scrollbarWidth = 0;\n        this.timerHideModal = 0;\n        this.timerRmBackDrop = 0;\n        this.isNested = false;\n        this._element = _element;\n        this._renderer = _renderer;\n        this._backdrop = clf.createLoader(_element, _viewContainerRef, _renderer);\n    }\n    Object.defineProperty(ModalDirective.prototype, \"config\", {\n        /**\n         * @return {?}\n         */\n        get: function () {\n            return this._config;\n        },\n        /**\n         * allows to set modal configuration via element property\n         * @param {?} conf\n         * @return {?}\n         */\n        set: function (conf) {\n            this._config = this.getConfig(conf);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ModalDirective.prototype, \"isShown\", {\n        /**\n         * @return {?}\n         */\n        get: function () {\n            return this._isShown;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n    ModalDirective.prototype.onClick = function (event) {\n        if (this.config.ignoreBackdropClick || this.config.backdrop === 'static' || event.target !== this._element.nativeElement) {\n            return;\n        }\n        this.dismissReason = DISMISS_REASONS.BACKRDOP;\n        this.hide(event);\n    };\n    /**\n     * @return {?}\n     */\n    ModalDirective.prototype.onEsc = function () {\n        if (this.config.keyboard) {\n            this.dismissReason = DISMISS_REASONS.ESC;\n            this.hide();\n        }\n    };\n    /**\n     * @return {?}\n     */\n    ModalDirective.prototype.ngOnDestroy = function () {\n        this.config = void 0;\n        if (this._isShown) {\n            this._isShown = false;\n            this.hideModal();\n            this._backdrop.dispose();\n        }\n    };\n    /**\n     * @return {?}\n     */\n    ModalDirective.prototype.ngAfterViewInit = function () {\n        var _this = this;\n        this._config = this._config || this.getConfig();\n        setTimeout(function () {\n            if (_this._config.show) {\n                _this.show();\n            }\n        }, 0);\n    };\n    /**\n     * Allows to manually toggle modal visibility\n     * @return {?}\n     */\n    ModalDirective.prototype.toggle = function () {\n        return this._isShown ? this.hide() : this.show();\n    };\n    /**\n     * Allows to manually open modal\n     * @return {?}\n     */\n    ModalDirective.prototype.show = function () {\n        var _this = this;\n        this.dismissReason = null;\n        this.onShow.emit(this);\n        this.open.emit(this);\n        if (this._isShown) {\n            return;\n        }\n        clearTimeout(this.timerHideModal);\n        clearTimeout(this.timerRmBackDrop);\n        this._isShown = true;\n        this.checkScrollbar();\n        this.setScrollbar();\n        if (document$1 && document$1.body) {\n            if (document$1.body.classList.contains(ClassName.OPEN)) {\n                this.isNested = true;\n            }\n            else {\n                this._renderer.addClass(document$1.body, ClassName.OPEN);\n            }\n        }\n        this.showBackdrop(function () {\n            _this.showElement();\n        });\n    };\n    /**\n     * Allows to manually close modal\n     * @param {?=} event\n     * @return {?}\n     */\n    ModalDirective.prototype.hide = function (event) {\n        var _this = this;\n        if (event) {\n            event.preventDefault();\n        }\n        this.onHide.emit(this);\n        this.close.emit(this);\n        // todo: add an option to prevent hiding\n        if (!this._isShown) {\n            return;\n        }\n        clearTimeout(this.timerHideModal);\n        clearTimeout(this.timerRmBackDrop);\n        this._isShown = false;\n        this._renderer.removeClass(this._element.nativeElement, ClassName.IN);\n        if (!isBs3()) {\n            this._renderer.removeClass(this._element.nativeElement, ClassName.SHOW);\n        }\n        if (this.isAnimated) {\n            this.timerHideModal = setTimeout(function () { return _this.hideModal(); }, TRANSITION_DURATION);\n        }\n        else {\n            this.hideModal();\n        }\n    };\n    /**\n     * Private methods \\@internal\n     * @param {?=} config\n     * @return {?}\n     */\n    ModalDirective.prototype.getConfig = function (config) {\n        return Object.assign({}, modalConfigDefaults, config);\n    };\n    /**\n     *  Show dialog\n     * \\@internal\n     * @return {?}\n     */\n    ModalDirective.prototype.showElement = function () {\n        var _this = this;\n        // todo: replace this with component loader usage\n        if (!this._element.nativeElement.parentNode ||\n            (this._element.nativeElement.parentNode.nodeType !== Node.ELEMENT_NODE)) {\n            // don't move modals dom position\n            if (document$1 && document$1.body) {\n                document$1.body.appendChild(this._element.nativeElement);\n            }\n        }\n        this._renderer.setAttribute(this._element.nativeElement, 'aria-hidden', 'false');\n        this._renderer.setStyle(this._element.nativeElement, 'display', 'block');\n        this._renderer.setProperty(this._element.nativeElement, 'scrollTop', 0);\n        if (this.isAnimated) {\n            Utils.reflow(this._element.nativeElement);\n        }\n        this._renderer.addClass(this._element.nativeElement, ClassName.IN);\n        if (!isBs3()) {\n            this._renderer.addClass(this._element.nativeElement, ClassName.SHOW);\n        }\n        /** @type {?} */\n        var transitionComplete = function () {\n            if (_this._config.focus) {\n                _this._element.nativeElement.focus();\n            }\n            _this.onShown.emit(_this);\n            _this.opened.emit(_this);\n        };\n        if (this.isAnimated) {\n            setTimeout(transitionComplete, TRANSITION_DURATION);\n        }\n        else {\n            transitionComplete();\n        }\n    };\n    /**\n     * \\@internal\n     * @return {?}\n     */\n    ModalDirective.prototype.hideModal = function () {\n        var _this = this;\n        this._renderer.setAttribute(this._element.nativeElement, 'aria-hidden', 'true');\n        this._renderer.setStyle(this._element.nativeElement, 'display', 'none');\n        this.showBackdrop(function () {\n            if (!_this.isNested) {\n                if (document$1 && document$1.body) {\n                    _this._renderer.removeClass(document$1.body, ClassName.OPEN);\n                }\n                _this.resetScrollbar();\n            }\n            _this.resetAdjustments();\n            _this.focusOtherModal();\n            _this.onHidden.emit(_this);\n            _this.closed.emit(_this);\n        });\n    };\n    /**\n     * \\@internal\n     * @param {?=} callback\n     * @return {?}\n     */\n    ModalDirective.prototype.showBackdrop = function (callback) {\n        var _this = this;\n        if (this._isShown && this.config.backdrop && (!this.backdrop || !this.backdrop.instance.isShown)) {\n            this.removeBackdrop();\n            this._backdrop\n                .attach(ModalBackdropComponent)\n                .to('body')\n                .show({ isAnimated: this.isAnimated });\n            this.backdrop = this._backdrop._componentRef;\n            if (!callback) {\n                return;\n            }\n            if (!this.isAnimated) {\n                callback();\n                return;\n            }\n            setTimeout(callback, BACKDROP_TRANSITION_DURATION);\n        }\n        else if (!this._isShown && this.backdrop) {\n            this.backdrop.instance.isShown = false;\n            /** @type {?} */\n            var callbackRemove = function () {\n                _this.removeBackdrop();\n                if (callback) {\n                    callback();\n                }\n            };\n            if (this.backdrop.instance.isAnimated) {\n                this.timerRmBackDrop = setTimeout(callbackRemove, BACKDROP_TRANSITION_DURATION);\n            }\n            else {\n                callbackRemove();\n            }\n        }\n        else if (callback) {\n            callback();\n        }\n    };\n    /**\n     * \\@internal\n     * @return {?}\n     */\n    ModalDirective.prototype.removeBackdrop = function () {\n        this._backdrop.hide();\n    };\n    /**\n     * @return {?}\n     */\n    ModalDirective.prototype.focusOtherModal = function () {\n        try {\n            /** @type {?} */\n            var otherOpenedModals = this._element.nativeElement.parentElement.querySelectorAll('.in[mdbModal]');\n            if (!otherOpenedModals.length) {\n                return;\n            }\n            //  this._renderer.invokeElementMethod(otherOpenedModals[otherOpenedModals.length - 1], 'focus');\n            otherOpenedModals[otherOpenedModals.length - 1].nativeElement.focus();\n        }\n        catch (error) { }\n    };\n    /**\n     * \\@internal\n     * @return {?}\n     */\n    ModalDirective.prototype.resetAdjustments = function () {\n        this._renderer.setStyle(this._element.nativeElement, 'paddingLeft', '');\n        this._renderer.setStyle(this._element.nativeElement, 'paddingRight', '');\n    };\n    /**\n     * \\@internal\n     * @return {?}\n     */\n    ModalDirective.prototype.checkScrollbar = function () {\n        this.isBodyOverflowing = document$1.body.clientWidth < win.innerWidth;\n        this.scrollbarWidth = this.getScrollbarWidth();\n    };\n    /**\n     * @return {?}\n     */\n    ModalDirective.prototype.setScrollbar = function () {\n        if (!document$1) {\n            return;\n        }\n        this.originalBodyPadding = parseInt(win.getComputedStyle(document$1.body).getPropertyValue('padding-right') || 0, 10);\n        if (this.isBodyOverflowing) {\n            document$1.body.style.paddingRight = this.originalBodyPadding + this.scrollbarWidth + \"px\";\n        }\n    };\n    /**\n     * @return {?}\n     */\n    ModalDirective.prototype.resetScrollbar = function () {\n        document$1.body.style.paddingRight = this.originalBodyPadding;\n    };\n    /**\n     * @return {?}\n     */\n    ModalDirective.prototype.getScrollbarWidth = function () {\n        /** @type {?} */\n        var scrollDiv = this._renderer.createElement('div', void 0);\n        this._renderer.appendChild(document$1.body, scrollDiv);\n        scrollDiv.className = ClassName.SCROLLBAR_MEASURER;\n        /** @type {?} */\n        var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;\n        document$1.body.removeChild(scrollDiv);\n        return scrollbarWidth;\n    };\n    return ModalDirective;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/** @type {?} */\nvar msConfig = {\n    serviceInstance: new Object()\n};\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\nvar ModalContainerComponent = /*@__PURE__*/ (function () {\n    /**\n     * @param {?} options\n     * @param {?} _element\n     * @param {?} _renderer\n     */\n    function ModalContainerComponent(options, _element, _renderer) {\n        this._renderer = _renderer;\n        this.tabindex = -1;\n        this.role = 'dialog';\n        this.modla = true;\n        this.isShown = false;\n        this.isModalHiding = false;\n        this.mdbModalService = msConfig.serviceInstance;\n        this._element = _element;\n        this.config = Object.assign({}, options);\n    }\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n    ModalContainerComponent.prototype.onClick = function (event) {\n        if (this.config.ignoreBackdropClick || this.config.backdrop === 'static' || event.target !== this._element.nativeElement) {\n            return;\n        }\n        this.mdbModalService.setDismissReason(DISMISS_REASONS.BACKRDOP);\n        this.hide();\n    };\n    /**\n     * @return {?}\n     */\n    ModalContainerComponent.prototype.onEsc = function () {\n        if (this.config.keyboard && this.level === this.mdbModalService.getModalsCount()) {\n            this.mdbModalService.setDismissReason(DISMISS_REASONS.ESC);\n            this.hide();\n        }\n    };\n    /**\n     * @return {?}\n     */\n    ModalContainerComponent.prototype.ngOnInit = function () {\n        var _this = this;\n        if (this.isAnimated) {\n            this._renderer.addClass(this._element.nativeElement, ClassName.FADE);\n        }\n        this._renderer.setStyle(this._element.nativeElement, 'display', 'block');\n        setTimeout(function () {\n            _this.isShown = true;\n            _this._renderer.addClass(_this._element.nativeElement, isBs3() ? ClassName.IN : ClassName.SHOW);\n        }, this.isAnimated ? TransitionDurations.BACKDROP : 0);\n        if (document && document.body) {\n            if (this.mdbModalService.getModalsCount() === 1) {\n                this.mdbModalService.checkScrollbar();\n                this.mdbModalService.setScrollbar();\n            }\n            this._renderer.addClass(document.body, ClassName.OPEN);\n        }\n    };\n    /**\n     * @return {?}\n     */\n    ModalContainerComponent.prototype.ngOnDestroy = function () {\n        if (this.isShown) {\n            this.hide();\n        }\n    };\n    /**\n     * @return {?}\n     */\n    ModalContainerComponent.prototype.hide = function () {\n        var _this = this;\n        if (this.isModalHiding || !this.isShown) {\n            return;\n        }\n        this.isModalHiding = true;\n        this._renderer.removeClass(this._element.nativeElement, isBs3() ? ClassName.IN : ClassName.SHOW);\n        setTimeout(function () {\n            _this.isShown = false;\n            if (document && document.body && _this.mdbModalService.getModalsCount() === 1) {\n                _this._renderer.removeClass(document.body, ClassName.OPEN);\n            }\n            _this.mdbModalService.hide(_this.level);\n            _this.isModalHiding = false;\n        }, this.isAnimated ? TransitionDurations.MODAL : 0);\n    };\n    return ModalContainerComponent;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\nvar MDBModalService = /*@__PURE__*/ (function () {\n    /**\n     * @param {?} clf\n     * @param {?} el\n     * @param {?} v\n     * @param {?} r\n     */\n    function MDBModalService(clf, el, v, r) {\n        this.clf = clf;\n        this.el = el;\n        this.v = v;\n        this.r = r;\n        this.config = modalConfigDefaults;\n        this.onShow = new EventEmitter();\n        this.onShown = new EventEmitter();\n        this.onHide = new EventEmitter();\n        this.onHidden = new EventEmitter();\n        this.isBodyOverflowing = false;\n        this.originalBodyPadding = 0;\n        this.scrollbarWidth = 0;\n        this.modalsCount = 0;\n        this.lastDismissReason = '';\n        this.loaders = [];\n        //   this._backdropLoader = this.clf.createLoader<ModalBackdropComponent>(null, null, null);\n        this._backdropLoader = this.clf.createLoader(this.el, this.v, this.r);\n        msConfig.serviceInstance = this;\n    }\n    /**\n     * Shows a modal\n     * @param {?} content\n     * @param {?=} config\n     * @return {?}\n     */\n    MDBModalService.prototype.show = function (content, config) {\n        this.modalsCount++;\n        this._createLoaders();\n        this.config = Object.assign({}, modalConfigDefaults, config);\n        this._showBackdrop();\n        this.lastDismissReason = null;\n        return this._showModal(content);\n    };\n    /**\n     * @param {?} level\n     * @return {?}\n     */\n    MDBModalService.prototype.hide = function (level) {\n        var _this = this;\n        if (this.modalsCount === 1) {\n            this._hideBackdrop();\n            this.resetScrollbar();\n        }\n        this.modalsCount = this.modalsCount >= 1 ? this.modalsCount - 1 : 0;\n        setTimeout(function () {\n            _this._hideModal(level);\n            _this.removeLoaders(level);\n        }, this.config.animated ? TransitionDurations.BACKDROP : 0);\n    };\n    /**\n     * @return {?}\n     */\n    MDBModalService.prototype._showBackdrop = function () {\n        /** @type {?} */\n        var isBackdropEnabled = this.config.backdrop || this.config.backdrop === 'static';\n        /** @type {?} */\n        var isBackdropInDOM = !this.backdropRef || !this.backdropRef.instance.isShown;\n        if (this.modalsCount === 1) {\n            this.removeBackdrop();\n            if (isBackdropEnabled && isBackdropInDOM) {\n                this._backdropLoader\n                    .attach(ModalBackdropComponent)\n                    .to('body')\n                    .show({ isAnimated: this.config.animated });\n                this.backdropRef = this._backdropLoader._componentRef;\n            }\n        }\n    };\n    /**\n     * @return {?}\n     */\n    MDBModalService.prototype._hideBackdrop = function () {\n        var _this = this;\n        if (!this.backdropRef) {\n            return;\n        }\n        this.backdropRef.instance.isShown = false;\n        /** @type {?} */\n        var duration = this.config.animated ? TransitionDurations.BACKDROP : 0;\n        setTimeout(function () { return _this.removeBackdrop(); }, duration);\n    };\n    /**\n     * @param {?} content\n     * @return {?}\n     */\n    MDBModalService.prototype._showModal = function (content) {\n        /** @type {?} */\n        var modalLoader = this.loaders[this.loaders.length - 1];\n        /** @type {?} */\n        var mdbModalRef = new MDBModalRef();\n        /** @type {?} */\n        var modalContainerRef = modalLoader\n            .provide({ provide: ModalOptions, useValue: this.config })\n            .provide({ provide: MDBModalRef, useValue: mdbModalRef })\n            .attach(ModalContainerComponent)\n            .to('body')\n            .show({ content: content, isAnimated: this.config.animated });\n        modalContainerRef.instance.level = this.getModalsCount();\n        mdbModalRef.hide = function () {\n            modalContainerRef.instance.hide();\n        };\n        mdbModalRef.content = modalLoader.getInnerComponent() || null;\n        return mdbModalRef;\n    };\n    /**\n     * @param {?} level\n     * @return {?}\n     */\n    MDBModalService.prototype._hideModal = function (level) {\n        /** @type {?} */\n        var modalLoader = this.loaders[level - 1];\n        if (modalLoader) {\n            modalLoader.hide();\n        }\n    };\n    /**\n     * @return {?}\n     */\n    MDBModalService.prototype.getModalsCount = function () {\n        return this.modalsCount;\n    };\n    /**\n     * @param {?} reason\n     * @return {?}\n     */\n    MDBModalService.prototype.setDismissReason = function (reason) {\n        this.lastDismissReason = reason;\n    };\n    /**\n     * @return {?}\n     */\n    MDBModalService.prototype.removeBackdrop = function () {\n        this._backdropLoader.hide();\n        this.backdropRef = null;\n    };\n    /**\n     * \\@internal\n     * @return {?}\n     */\n    MDBModalService.prototype.checkScrollbar = function () {\n        this.isBodyOverflowing = document.body.clientWidth < window.innerWidth;\n        this.scrollbarWidth = this.getScrollbarWidth();\n    };\n    /**\n     * @return {?}\n     */\n    MDBModalService.prototype.setScrollbar = function () {\n        if (!document) {\n            return;\n        }\n        this.originalBodyPadding = parseInt(window.getComputedStyle(document.body).getPropertyValue('padding-right') || '0', 10);\n        if (this.isBodyOverflowing) {\n            document.body.style.paddingRight = this.originalBodyPadding + this.scrollbarWidth + \"px\";\n        }\n    };\n    /**\n     * @return {?}\n     */\n    MDBModalService.prototype.resetScrollbar = function () {\n        document.body.style.paddingRight = this.originalBodyPadding + 'px';\n    };\n    /**\n     * @return {?}\n     */\n    MDBModalService.prototype.getScrollbarWidth = function () {\n        /** @type {?} */\n        var scrollDiv = document.createElement('div');\n        scrollDiv.className = ClassName.SCROLLBAR_MEASURER;\n        document.body.appendChild(scrollDiv);\n        /** @type {?} */\n        var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;\n        document.body.removeChild(scrollDiv);\n        return scrollbarWidth;\n    };\n    /**\n     * @return {?}\n     */\n    MDBModalService.prototype._createLoaders = function () {\n        /** @type {?} */\n        var loader = this.clf.createLoader(this.el, this.v, this.r);\n        this.copyEvent(loader.onBeforeShow, this.onShow);\n        this.copyEvent(loader.onShown, this.onShown);\n        this.copyEvent(loader.onBeforeHide, this.onHide);\n        this.copyEvent(loader.onHidden, this.onHidden);\n        this.loaders.push(loader);\n    };\n    /**\n     * @param {?} level\n     * @return {?}\n     */\n    MDBModalService.prototype.removeLoaders = function (level) {\n        this.loaders.splice(level - 1, 1);\n        this.loaders.forEach(function (loader, i) {\n            loader.instance.level = i + 1;\n        });\n    };\n    /**\n     * @param {?} from\n     * @param {?} to\n     * @return {?}\n     */\n    MDBModalService.prototype.copyEvent = function (from, to) {\n        var _this = this;\n        from.subscribe(function () {\n            to.emit(_this.lastDismissReason);\n        });\n    };\n    return MDBModalService;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\nvar ModalModule = /*@__PURE__*/ (function () {\n    function ModalModule() {\n    }\n    /**\n     * @return {?}\n     */\n    ModalModule.forRoot = function () {\n        return { ngModule: ModalModule, providers: [MDBModalService, ComponentLoaderFactory, PositioningService] };\n    };\n    return ModalModule;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * Default values provider for tooltip\n */\nvar TooltipConfig = /*@__PURE__*/ (function () {\n    function TooltipConfig() {\n        /**\n         * tooltip placement, supported positions: 'top', 'bottom', 'left', 'right'\n         */\n        this.placement = 'top';\n        /**\n         * array of event names which triggers tooltip opening\n         */\n        this.triggers = 'hover focus';\n    }\n    return TooltipConfig;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\nvar TooltipContainerComponent = /*@__PURE__*/ (function () {\n    /**\n     * @param {?} config\n     * @param {?} r\n     */\n    function TooltipContainerComponent(config, r) {\n        this.r = r;\n        this.show = !this.isBs3;\n        Object.assign(this, config);\n    }\n    Object.defineProperty(TooltipContainerComponent.prototype, \"isBs3\", {\n        /**\n         * @return {?}\n         */\n        get: function () {\n            return isBs3();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    TooltipContainerComponent.prototype.ngAfterViewInit = function () {\n        var _this = this;\n        this.classMap = { in: false, fade: false };\n        this.classMap[this.placement] = true;\n        this.classMap['tooltip-' + this.placement] = true;\n        this.classMap.in = true;\n        if (this.animation) {\n            this.classMap.fade = true;\n        }\n        if (this.popupClass) {\n            this.classMap[this.popupClass] = true;\n        }\n        setTimeout(function () {\n            /** @type {?} */\n            var arrowClassList = _this.tooltipArrow.nativeElement.classList;\n            /** @type {?} */\n            var tooltipHeight = _this.tooltipInner.nativeElement.clientHeight;\n            if (arrowClassList.contains('top')) {\n                _this.r.setStyle(_this.tooltipArrow.nativeElement, 'top', tooltipHeight + 6 + 'px');\n            }\n            else if (arrowClassList.contains('left')) {\n                _this.r.setStyle(_this.tooltipArrow.nativeElement, 'top', (tooltipHeight / 2) + 'px');\n            }\n            else if (arrowClassList.contains('right')) {\n                _this.r.setStyle(_this.tooltipArrow.nativeElement, 'top', (tooltipHeight / 2) + 'px');\n            }\n        }, 0);\n    };\n    return TooltipContainerComponent;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * @return {?}\n */\nfunction OnChange() {\n    /** @type {?} */\n    var sufix = 'Change';\n    return function OnChangeHandler(target, propertyKey) {\n        /** @type {?} */\n        var _key = \" __\" + propertyKey + \"Value\";\n        Object.defineProperty(target, propertyKey, {\n            /**\n             * @return {?}\n             */\n            get: function () { return this[_key]; },\n            /**\n             * @param {?} value\n             * @return {?}\n             */\n            set: function (value) {\n                /** @type {?} */\n                var prevValue = this[_key];\n                this[_key] = value;\n                if (prevValue !== value && this[propertyKey + sufix]) {\n                    this[propertyKey + sufix].emit(value);\n                }\n            }\n        });\n    };\n}\n/* tslint:enable */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\nvar TooltipDirective = /*@__PURE__*/ (function () {\n    /**\n     * @param {?} _viewContainerRef\n     * @param {?} _renderer\n     * @param {?} _elementRef\n     * @param {?} cis\n     * @param {?} config\n     */\n    function TooltipDirective(_viewContainerRef, _renderer, _elementRef, cis, config) {\n        /**\n         * Fired when tooltip content changes\n         */\n        this.tooltipChange = new EventEmitter();\n        this.delay = 0;\n        this.fadeDuration = 150;\n        this._tooltip = cis\n            .createLoader(_elementRef, _viewContainerRef, _renderer)\n            .provide({ provide: TooltipConfig, useValue: config });\n        Object.assign(this, config);\n        this.onShown = this._tooltip.onShown;\n        this.shown = this._tooltip.onShown;\n        this.onHidden = this._tooltip.onHidden;\n        this.hidden = this._tooltip.onHidden;\n    }\n    Object.defineProperty(TooltipDirective.prototype, \"isOpen\", {\n        /**\n         * Returns whether or not the tooltip is currently being shown\n         * @return {?}\n         */\n        get: function () { return this._tooltip.isShown; },\n        /**\n         * @param {?} value\n         * @return {?}\n         */\n        set: function (value) {\n            if (value) {\n                this.show();\n            }\n            else {\n                this.hide();\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    TooltipDirective.prototype.ngOnInit = function () {\n        var _this = this;\n        this._tooltip.listen({\n            triggers: this.triggers,\n            show: function () { return _this.show(); }\n        });\n        this.tooltipChange.subscribe(function (value) {\n            if (!value) {\n                _this._tooltip.hide();\n            }\n        });\n    };\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n    TooltipDirective.prototype.ngOnChanges = function (changes) {\n        if (!changes['mdbTooltip'].isFirstChange()) {\n            this.tooltipChange.emit(this.mdbTooltip);\n        }\n    };\n    /**\n     * Toggles an elements tooltip. This is considered a manual triggering of\n     * the tooltip.\n     * @return {?}\n     */\n    TooltipDirective.prototype.toggle = function () {\n        if (this.isOpen) {\n            return this.hide();\n        }\n        this.show();\n    };\n    /**\n     * Opens an elements tooltip. This is considered a manual triggering of\n     * the tooltip.\n     * @return {?}\n     */\n    TooltipDirective.prototype.show = function () {\n        var _this = this;\n        if (this.isOpen || this.isDisabled || this._delayTimeoutId || !this.mdbTooltip) {\n            return;\n        }\n        /** @type {?} */\n        var showTooltip = function () {\n            return _this._tooltip\n                .attach(TooltipContainerComponent)\n                .to(_this.container)\n                .position({ attachment: _this.placement })\n                .show({\n                content: _this.mdbTooltip,\n                placement: _this.placement\n            });\n        };\n        if (this.delay) {\n            this._delayTimeoutId = setTimeout(function () { showTooltip(); }, this.delay);\n        }\n        else {\n            showTooltip();\n        }\n    };\n    /**\n     * Closes an elements tooltip. This is considered a manual triggering of\n     * the tooltip.\n     * @return {?}\n     */\n    TooltipDirective.prototype.hide = function () {\n        var _this = this;\n        if (this._delayTimeoutId) {\n            clearTimeout(this._delayTimeoutId);\n            this._delayTimeoutId = undefined;\n        }\n        if (!this._tooltip.isShown) {\n            return;\n        }\n        this._tooltip.instance.classMap.in = false;\n        setTimeout(function () {\n            _this._tooltip.hide();\n        }, this.fadeDuration);\n    };\n    /**\n     * @return {?}\n     */\n    TooltipDirective.prototype.dispose = function () {\n        this._tooltip.dispose();\n    };\n    /**\n     * @return {?}\n     */\n    TooltipDirective.prototype.ngOnDestroy = function () {\n        this._tooltip.dispose();\n    };\n    return TooltipDirective;\n}());\n__decorate([\n    OnChange(),\n    __metadata(\"design:type\", Object)\n], TooltipDirective.prototype, \"mdbTooltip\", void 0);\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\nvar TooltipModule = /*@__PURE__*/ (function () {\n    function TooltipModule() {\n    }\n    /**\n     * @return {?}\n     */\n    TooltipModule.forRoot = function () {\n        return {\n            ngModule: TooltipModule,\n            providers: [TooltipConfig, ComponentLoaderFactory, PositioningService]\n        };\n    };\n    return TooltipModule;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * Configuration service for the Popover directive.\n * You can inject this service, typically in your root component, and customize\n * the values of its properties in order to provide default values for all the\n * popovers used in the application.\n */\nvar PopoverConfig = /*@__PURE__*/ (function () {\n    function PopoverConfig() {\n        /**\n         * Placement of a popover. Accepts: \"top\", \"bottom\", \"left\", \"right\"\n         */\n        this.placement = 'top';\n        /**\n         * Specifies events that should trigger. Supports a space separated list of\n         * event names.\n         */\n        this.triggers = 'click';\n    }\n    return PopoverConfig;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\nvar PopoverContainerComponent = /*@__PURE__*/ (function () {\n    /**\n     * @param {?} config\n     */\n    function PopoverContainerComponent(config) {\n        this.show = '!isBs3';\n        this.role = 'tooltip';\n        Object.assign(this, config);\n    }\n    Object.defineProperty(PopoverContainerComponent.prototype, \"isBs3\", {\n        /**\n         * @return {?}\n         */\n        get: function () {\n            return isBs3();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    PopoverContainerComponent.prototype.ngOnInit = function () {\n        this.class = 'popover-fadeIn popover in popover-' + this.placement + ' ' + this.placement + ' bs-popover-' + this.placement;\n    };\n    return PopoverContainerComponent;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * A lightweight, extensible directive for fancy popover creation.\n */\nvar PopoverDirective = /*@__PURE__*/ (function () {\n    /**\n     * @param {?} _elementRef\n     * @param {?} _renderer\n     * @param {?} _viewContainerRef\n     * @param {?} _config\n     * @param {?} cis\n     */\n    function PopoverDirective(_elementRef, _renderer, _viewContainerRef, _config, cis) {\n        this._popover = cis\n            .createLoader(_elementRef, _viewContainerRef, _renderer)\n            .provide({ provide: PopoverConfig, useValue: _config });\n        Object.assign(this, _config);\n        this.onShown = this._popover.onShown;\n        this.shown = this._popover.onShown;\n        this.onHidden = this._popover.onHidden;\n        this.hidden = this._popover.onHidden;\n    }\n    Object.defineProperty(PopoverDirective.prototype, \"isOpen\", {\n        /**\n         * Returns whether or not the popover is currently being shown\n         * @return {?}\n         */\n        get: function () { return this._popover.isShown; },\n        /**\n         * @param {?} value\n         * @return {?}\n         */\n        set: function (value) {\n            if (value) {\n                this.show();\n            }\n            else {\n                this.hide();\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Opens an elements popover. This is considered a manual triggering of\n     * the popover.\n     * @return {?}\n     */\n    PopoverDirective.prototype.show = function () {\n        if (this._popover.isShown) {\n            return;\n        }\n        this._popover\n            .attach(PopoverContainerComponent)\n            .to(this.container)\n            .position({ attachment: this.placement })\n            .show({\n            content: this.mdbPopover,\n            placement: this.placement,\n            title: this.mdbPopoverHeader || this.popoverTitle\n        });\n        this.isOpen = true;\n    };\n    /**\n     * Closes an elements popover. This is considered a manual triggering of\n     * the popover.\n     * @return {?}\n     */\n    PopoverDirective.prototype.hide = function () {\n        if (this.isOpen) {\n            this._popover.hide();\n            this.isOpen = false;\n        }\n    };\n    /**\n     * Toggles an elements popover. This is considered a manual triggering of\n     * the popover.\n     * @return {?}\n     */\n    PopoverDirective.prototype.toggle = function () {\n        if (this.isOpen) {\n            return this.hide();\n        }\n        this.show();\n    };\n    /**\n     * @return {?}\n     */\n    PopoverDirective.prototype.ngOnInit = function () {\n        var _this = this;\n        this._popover.listen({\n            triggers: this.triggers,\n            show: function () { return _this.show(); }\n        });\n    };\n    /**\n     * @return {?}\n     */\n    PopoverDirective.prototype.dispose = function () {\n        this._popover.dispose();\n    };\n    /**\n     * @return {?}\n     */\n    PopoverDirective.prototype.ngOnDestroy = function () {\n        this._popover.dispose();\n    };\n    return PopoverDirective;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\nvar PopoverModule = /*@__PURE__*/ (function () {\n    function PopoverModule() {\n    }\n    /**\n     * @return {?}\n     */\n    PopoverModule.forRoot = function () {\n        return {\n            ngModule: PopoverModule,\n            providers: [PopoverConfig, ComponentLoaderFactory, PositioningService]\n        };\n    };\n    return PopoverModule;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\nvar WavesDirective = /*@__PURE__*/ (function () {\n    /**\n     * @param {?} el\n     */\n    function WavesDirective(el) {\n        this.el = el;\n    }\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n    WavesDirective.prototype.click = function (event) {\n        // event.stopPropagation();\n        if (!this.el.nativeElement.classList.contains('disabled')) {\n            /** @type {?} */\n            var button = this.el.nativeElement;\n            if (!button.classList.contains('waves-effect')) {\n                button.className += ' waves-effect';\n            }\n            /** @type {?} */\n            var xPos = event.clientX - button.getBoundingClientRect().left;\n            /** @type {?} */\n            var yPos = event.clientY - button.getBoundingClientRect().top;\n            /** @type {?} */\n            var tmp = document.createElement('div');\n            tmp.className += 'waves-ripple waves-rippling';\n            /** @type {?} */\n            var ripple = button.appendChild(tmp);\n            /** @type {?} */\n            var top = yPos + 'px';\n            /** @type {?} */\n            var left = xPos + 'px';\n            tmp.style.top = top;\n            tmp.style.left = left;\n            /** @type {?} */\n            var scale = 'scale(' + ((button.clientWidth / 100) * 3) + ') translate(0,0)';\n            tmp.style.webkitTransform = scale;\n            tmp.style.transform = scale;\n            tmp.style.opacity = '1';\n            /** @type {?} */\n            var duration = 750;\n            tmp.style.webkitTransitionDuration = duration + 'ms';\n            tmp.style.transitionDuration = duration + 'ms';\n            this.removeRipple(button, ripple);\n        }\n    };\n    /**\n     * @param {?} button\n     * @param {?} ripple\n     * @return {?}\n     */\n    WavesDirective.prototype.removeRipple = function (button, ripple) {\n        ripple.classList.remove('waves-rippling');\n        setTimeout(function () {\n            ripple.style.opacity = '0';\n            setTimeout(function () {\n                button.removeChild(ripple);\n            }, 750);\n        }, 200);\n    };\n    return WavesDirective;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\nvar WavesModule = /*@__PURE__*/ (function () {\n    function WavesModule() {\n    }\n    /**\n     * @return {?}\n     */\n    WavesModule.forRoot = function () {\n        return { ngModule: WavesModule, providers: [] };\n    };\n    return WavesModule;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\nvar MdbIconComponent = /*@__PURE__*/ (function () {\n    function MdbIconComponent() {\n    }\n    return MdbIconComponent;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\nvar IconsModule = /*@__PURE__*/ (function () {\n    function IconsModule() {\n    }\n    return IconsModule;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/** @type {?} */\nvar CHECKBOX_VALUE_ACCESSOR = {\n    provide: NG_VALUE_ACCESSOR,\n    useExisting: forwardRef(function () { return CheckboxComponent; }),\n    multi: true\n};\n/** @type {?} */\nvar defaultIdNumber = 0;\nvar MdbCheckboxChange = /*@__PURE__*/ (function () {\n    function MdbCheckboxChange() {\n    }\n    return MdbCheckboxChange;\n}());\nvar CheckboxComponent = /*@__PURE__*/ (function () {\n    function CheckboxComponent() {\n        this.defaultId = \"mdb-checkbox-\" + ++defaultIdNumber;\n        this.id = this.defaultId;\n        this.checked = false;\n        this.filledIn = false;\n        this.indeterminate = false;\n        this.rounded = false;\n        this.checkboxPosition = 'left';\n        this.default = false;\n        this.inline = false;\n        this.change = new EventEmitter();\n        // Control Value Accessor Methods\n        this.onChange = function (_) { };\n        this.onTouched = function () { };\n    }\n    /**\n     * @return {?}\n     */\n    CheckboxComponent.prototype.ngOnInit = function () {\n        if (this.indeterminate && !this.filledIn && !this.rounded) {\n            this.inputEl.indeterminate = true;\n        }\n    };\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n    CheckboxComponent.prototype.ngOnChanges = function (changes) {\n        if (changes.hasOwnProperty('checked')) {\n            this.checked = changes[\"checked\"].currentValue;\n        }\n    };\n    Object.defineProperty(CheckboxComponent.prototype, \"changeEvent\", {\n        /**\n         * @return {?}\n         */\n        get: function () {\n            /** @type {?} */\n            var newChangeEvent = new MdbCheckboxChange();\n            newChangeEvent.element = this;\n            newChangeEvent.checked = this.checked;\n            return newChangeEvent;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    CheckboxComponent.prototype.toggle = function () {\n        if (this.disabled) {\n            return;\n        }\n        this.checked = !this.checked;\n        this.indeterminate = false;\n        this.onChange(this.checked);\n    };\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n    CheckboxComponent.prototype.onCheckboxClick = function (event) {\n        event.stopPropagation();\n        this.toggle();\n    };\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n    CheckboxComponent.prototype.onCheckboxChange = function (event) {\n        event.stopPropagation();\n        this.change.emit(this.changeEvent);\n    };\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    CheckboxComponent.prototype.writeValue = function (value) {\n        this.value = value;\n        this.checked = !!value;\n    };\n    /**\n     * @param {?} fn\n     * @return {?}\n     */\n    CheckboxComponent.prototype.registerOnChange = function (fn) {\n        this.onChange = fn;\n    };\n    /**\n     * @param {?} fn\n     * @return {?}\n     */\n    CheckboxComponent.prototype.registerOnTouched = function (fn) {\n        this.onTouched = fn;\n    };\n    /**\n     * @param {?} isDisabled\n     * @return {?}\n     */\n    CheckboxComponent.prototype.setDisabledState = function (isDisabled) {\n        this.disabled = isDisabled;\n    };\n    return CheckboxComponent;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\nvar CheckboxModule = /*@__PURE__*/ (function () {\n    function CheckboxModule() {\n    }\n    return CheckboxModule;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\nvar MdbTableDirective = /*@__PURE__*/ (function () {\n    /**\n     * @param {?} el\n     * @param {?} renderer\n     */\n    function MdbTableDirective(el, renderer) {\n        this.el = el;\n        this.renderer = renderer;\n        this.stickyHeader = false;\n        this.stickyHeaderBgColor = '';\n        this.stickyHeaderTextColor = '';\n    }\n    /**\n     * @return {?}\n     */\n    MdbTableDirective.prototype.ngOnInit = function () {\n        this.renderer.addClass(this.el.nativeElement, 'table');\n        if (this.stickyHeader) {\n            /** @type {?} */\n            var tableHead = this.el.nativeElement.querySelector('thead');\n            this.renderer.addClass(tableHead, 'sticky-top');\n            if (this.stickyHeaderBgColor) {\n                this.renderer.setStyle(tableHead, 'background-color', this.stickyHeaderBgColor);\n            }\n            else {\n                this.renderer.setStyle(tableHead, 'background-color', '#f2f2f2');\n            }\n            if (this.stickyHeaderTextColor) {\n                this.renderer.setStyle(tableHead, 'color', this.stickyHeaderTextColor);\n            }\n            else {\n                this.renderer.setStyle(tableHead, 'color', '#000000');\n            }\n        }\n    };\n    return MdbTableDirective;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\nvar MdbTableSortDirective = /*@__PURE__*/ (function () {\n    function MdbTableSortDirective() {\n        // tslint:disable-next-line:no-input-rename\n        this.dataSource = [];\n        this.sorted = false;\n    }\n    /**\n     * @return {?}\n     */\n    MdbTableSortDirective.prototype.onclick = function () {\n        this.sortDataBy(this.sortBy.toLowerCase());\n    };\n    /**\n     * @param {?} key\n     * @return {?}\n     */\n    MdbTableSortDirective.prototype.sortDataBy = function (key) {\n        var _this = this;\n        this.dataSource.sort(function (a, b) {\n            if (a[key] < b[key]) {\n                return _this.sorted ? 1 : -1;\n            }\n            if (a[key] > b[key]) {\n                return _this.sorted ? -1 : 1;\n            }\n            return 0;\n        });\n        this.sorted = !this.sorted;\n    };\n    return MdbTableSortDirective;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\nvar MdbTableScrollDirective = /*@__PURE__*/ (function () {\n    /**\n     * @param {?} renderer\n     * @param {?} el\n     */\n    function MdbTableScrollDirective(renderer, el) {\n        this.renderer = renderer;\n        this.el = el;\n        this.scrollY = false;\n        this.maxHeight = null;\n        this.scrollX = false;\n        this.maxWidth = null;\n    }\n    /**\n     * @param {?} tableWrapper\n     * @return {?}\n     */\n    MdbTableScrollDirective.prototype.wrapTableWithVerticalScrollingWrapper = function (tableWrapper) {\n        this.renderer.setStyle(tableWrapper, 'max-height', this.maxHeight + 'px');\n        this.renderer.setStyle(tableWrapper, 'overflow-y', 'auto');\n        this.renderer.setStyle(tableWrapper, 'display', 'block');\n    };\n    /**\n     * @param {?} tableWrapper\n     * @return {?}\n     */\n    MdbTableScrollDirective.prototype.wrapTableWithHorizontalScrollingWrapper = function (tableWrapper) {\n        this.renderer.setStyle(tableWrapper, 'max-width', this.maxWidth + 'px');\n        this.renderer.setStyle(tableWrapper, 'overflow-x', 'auto');\n        this.renderer.setStyle(tableWrapper, 'display', 'block');\n    };\n    /**\n     * @param {?} tableWrapper\n     * @return {?}\n     */\n    MdbTableScrollDirective.prototype.wrapTableWithHorizontalAndVerticalScrollingWrapper = function (tableWrapper) {\n        this.renderer.setStyle(tableWrapper, 'max-height', this.maxHeight + 'px');\n        this.renderer.setStyle(tableWrapper, 'max-width', this.maxWidth + 'px');\n        this.renderer.setStyle(tableWrapper, 'overflow-x', 'auto');\n        this.renderer.setStyle(tableWrapper, 'display', 'block');\n    };\n    /**\n     * @return {?}\n     */\n    MdbTableScrollDirective.prototype.ngOnInit = function () {\n        /** @type {?} */\n        var parent = this.el.nativeElement.parentNode;\n        /** @type {?} */\n        var tableWrapper = this.renderer.createElement('div');\n        if (this.scrollY && this.scrollX && this.maxHeight && this.maxWidth) {\n            this.wrapTableWithHorizontalAndVerticalScrollingWrapper(tableWrapper);\n        }\n        if (this.scrollY && this.maxHeight) {\n            this.wrapTableWithVerticalScrollingWrapper(tableWrapper);\n        }\n        if (this.scrollX && this.maxWidth) {\n            this.wrapTableWithHorizontalScrollingWrapper(tableWrapper);\n        }\n        this.renderer.insertBefore(parent, tableWrapper, this.el.nativeElement);\n        this.renderer.removeChild(parent, this.el.nativeElement);\n        this.renderer.appendChild(tableWrapper, this.el.nativeElement);\n    };\n    return MdbTableScrollDirective;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\nvar MdbTableRowDirective = /*@__PURE__*/ (function () {\n    /**\n     * @param {?} el\n     */\n    function MdbTableRowDirective(el) {\n        this.el = el;\n        this.rowCreated = new EventEmitter();\n        this.rowRemoved = new EventEmitter();\n    }\n    /**\n     * @return {?}\n     */\n    MdbTableRowDirective.prototype.ngOnInit = function () {\n        this.rowCreated.emit({ created: true, el: this.el.nativeElement });\n    };\n    /**\n     * @return {?}\n     */\n    MdbTableRowDirective.prototype.ngOnDestroy = function () {\n        this.rowRemoved.emit({ removed: true });\n    };\n    return MdbTableRowDirective;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\nvar MdbTableService = /*@__PURE__*/ (function () {\n    function MdbTableService() {\n        this._dataSource = [];\n    }\n    /**\n     * @param {?} newRow\n     * @return {?}\n     */\n    MdbTableService.prototype.addRow = function (newRow) {\n        this.getDataSource().push(newRow);\n    };\n    /**\n     * @param {?} index\n     * @param {?} row\n     * @return {?}\n     */\n    MdbTableService.prototype.addRowAfter = function (index, row) {\n        this.getDataSource().splice(index, 0, row);\n    };\n    /**\n     * @param {?} index\n     * @return {?}\n     */\n    MdbTableService.prototype.removeRow = function (index) {\n        this.getDataSource().splice(index, 1);\n    };\n    /**\n     * @return {?}\n     */\n    MdbTableService.prototype.rowRemoved = function () {\n        /** @type {?} */\n        var rowRemoved = Observable.create(function (observer) {\n            observer.next(true);\n        });\n        return rowRemoved;\n    };\n    /**\n     * @return {?}\n     */\n    MdbTableService.prototype.removeLastRow = function () {\n        this.getDataSource().pop();\n    };\n    /**\n     * @param {?} data\n     * @return {?}\n     */\n    MdbTableService.prototype.setDataSource = function (data) {\n        this._dataSource = data;\n    };\n    /**\n     * @return {?}\n     */\n    MdbTableService.prototype.getDataSource = function () {\n        return this._dataSource;\n    };\n    /**\n     * @return {?}\n     */\n    MdbTableService.prototype.dataSourceChange = function () {\n        var _this = this;\n        /** @type {?} */\n        var dataSourceChanged = Observable.create(function (observer) {\n            observer.next(_this.getDataSource());\n        });\n        return dataSourceChanged;\n    };\n    /**\n     * @param {?} searchKey\n     * @return {?}\n     */\n    MdbTableService.prototype.filterLocalDataBy = function (searchKey) {\n        return this.getDataSource().filter(function (obj) {\n            return Object.keys(obj).some(function (key) {\n                return (obj[key].toLowerCase()).includes(searchKey);\n            });\n        });\n    };\n    /**\n     * @param {?} searchKey\n     * @return {?}\n     */\n    MdbTableService.prototype.searchLocalDataBy = function (searchKey) {\n        if (!searchKey) {\n            return this.getDataSource();\n        }\n        if (searchKey) {\n            return this.filterLocalDataBy(searchKey);\n        }\n    };\n    /**\n     * @param {?} searchKey\n     * @return {?}\n     */\n    MdbTableService.prototype.searchDataObservable = function (searchKey) {\n        var _this = this;\n        /** @type {?} */\n        var observable = Observable.create(function (observer) {\n            observer.next(_this.searchLocalDataBy(searchKey));\n        });\n        return observable;\n    };\n    /** @nocollapse */ MdbTableService.ngInjectableDef = defineInjectable({ factory: function MdbTableService_Factory() { return new MdbTableService(); }, token: MdbTableService, providedIn: \"root\" });\n    return MdbTableService;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\nvar MdbTablePaginationComponent = /*@__PURE__*/ (function () {\n    /**\n     * @param {?} tableService\n     * @param {?} cdRef\n     */\n    function MdbTablePaginationComponent(tableService, cdRef) {\n        this.tableService = tableService;\n        this.cdRef = cdRef;\n        this.searchPagination = false;\n        this.searchDataSource = null;\n        this.paginationAlign = '';\n        this.hideDescription = false;\n        this.maxVisibleItems = 10;\n        this.firstItemIndex = 0;\n        this.lastItemIndex = this.maxVisibleItems;\n        this.lastVisibleItemIndex = 5;\n        this.activePageNumber = 1;\n        this.allItemsLength = 0;\n        this.nextShouldBeDisabled = false;\n        this.previousShouldBeDisabled = true;\n        this.searchText = '';\n        this.nextPageClick = new EventEmitter();\n        this.previousPageClick = new EventEmitter();\n    }\n    /**\n     * @return {?}\n     */\n    MdbTablePaginationComponent.prototype.ngOnInit = function () {\n        this.allItemsLength = this.tableService.getDataSource().length;\n    };\n    /**\n     * @return {?}\n     */\n    MdbTablePaginationComponent.prototype.ngAfterViewChecked = function () {\n        var _this = this;\n        this.tableService.dataSourceChange().subscribe(function (data) {\n            _this.allItemsLength = data.length;\n            _this.lastVisibleItemIndex = data.length;\n            _this.calculateFirstItemIndex();\n            _this.calculateLastItemIndex();\n            _this.disableNextButton(data);\n            _this.cdRef.detectChanges();\n        });\n    };\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n    MdbTablePaginationComponent.prototype.ngOnChanges = function (changes) {\n        /** @type {?} */\n        var searchDataSource = changes['searchDataSource'];\n        if (searchDataSource.currentValue.length !== 0) {\n            this.allItemsLength = searchDataSource.currentValue.length;\n        }\n        if (this.lastVisibleItemIndex > this.allItemsLength) {\n            this.lastVisibleItemIndex = this.allItemsLength;\n        }\n        if (searchDataSource.currentValue.length === 0) {\n            this.firstItemIndex = 0;\n            this.lastItemIndex = 0;\n            this.lastVisibleItemIndex = 0;\n            this.allItemsLength = 0;\n        }\n        else {\n            this.lastVisibleItemIndex = this.maxVisibleItems;\n        }\n        if (searchDataSource.currentValue.length <= this.maxVisibleItems) {\n            this.nextShouldBeDisabled = true;\n            this.lastVisibleItemIndex = searchDataSource.currentValue.length;\n        }\n        else {\n            this.nextShouldBeDisabled = false;\n        }\n    };\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    MdbTablePaginationComponent.prototype.setMaxVisibleItemsNumberTo = function (value) {\n        this.lastItemIndex = value;\n        this.lastVisibleItemIndex = value;\n        this.maxVisibleItems = value;\n        if (this.maxVisibleItems > this.allItemsLength) {\n            this.maxVisibleItems = this.allItemsLength;\n        }\n        this.cdRef.detectChanges();\n    };\n    /**\n     * @return {?}\n     */\n    MdbTablePaginationComponent.prototype.searchTextObs = function () {\n        var _this = this;\n        /** @type {?} */\n        var observable = Observable.create(function (observer) {\n            observer.next(_this.searchText);\n        });\n        return observable;\n    };\n    /**\n     * @param {?} data\n     * @return {?}\n     */\n    MdbTablePaginationComponent.prototype.disableNextButton = function (data) {\n        if (data.length <= this.maxVisibleItems) {\n            this.nextShouldBeDisabled = true;\n        }\n        else {\n            this.nextShouldBeDisabled = false;\n        }\n    };\n    /**\n     * @return {?}\n     */\n    MdbTablePaginationComponent.prototype.calculateFirstItemIndex = function () {\n        this.firstItemIndex = this.activePageNumber * this.maxVisibleItems - this.maxVisibleItems + 1;\n    };\n    /**\n     * @return {?}\n     */\n    MdbTablePaginationComponent.prototype.calculateLastItemIndex = function () {\n        this.lastItemIndex = this.activePageNumber * this.maxVisibleItems;\n        this.lastVisibleItemIndex = this.lastItemIndex;\n        if (this.searchDataSource && (this.lastItemIndex > this.searchDataSource.length)) {\n            this.lastVisibleItemIndex = this.searchDataSource.length;\n        }\n        else if (!this.searchDataSource) {\n            this.lastVisibleItemIndex = this.lastItemIndex;\n        }\n        if (this.lastItemIndex > this.tableService.getDataSource().length) {\n            this.lastItemIndex = this.tableService.getDataSource().length;\n        }\n    };\n    /**\n     * @return {?}\n     */\n    MdbTablePaginationComponent.prototype.calculateHowManyPagesShouldBe = function () {\n        return Math.ceil(this.tableService.getDataSource().length / this.maxVisibleItems);\n    };\n    /**\n     * @return {?}\n     */\n    MdbTablePaginationComponent.prototype.previousPage = function () {\n        this.activePageNumber--;\n        this.calculateFirstItemIndex();\n        this.calculateLastItemIndex();\n        this.previousPageClick.emit({ first: this.firstItemIndex, last: this.lastItemIndex });\n    };\n    /**\n     * @return {?}\n     */\n    MdbTablePaginationComponent.prototype.nextPage = function () {\n        this.activePageNumber++;\n        this.calculateFirstItemIndex();\n        this.calculateLastItemIndex();\n        if (this.lastItemIndex > this.tableService.getDataSource().length) {\n            this.lastItemIndex = this.tableService.getDataSource().length;\n        }\n        if (this.lastVisibleItemIndex > this.allItemsLength) {\n            this.lastVisibleItemIndex = this.allItemsLength;\n        }\n        this.nextPageClick.emit({ first: this.firstItemIndex, last: this.lastItemIndex });\n    };\n    /**\n     * @return {?}\n     */\n    MdbTablePaginationComponent.prototype.nextPageObservable = function () {\n        var _this = this;\n        /** @type {?} */\n        var obs = Observable.create(function (observer) {\n            observer.next(_this.firstItemIndex);\n        });\n        return obs;\n    };\n    /**\n     * @return {?}\n     */\n    MdbTablePaginationComponent.prototype.previousPageObservable = function () {\n        var _this = this;\n        /** @type {?} */\n        var obs = Observable.create(function (observer) {\n            observer.next(_this.lastVisibleItemIndex);\n        });\n        return obs;\n    };\n    /**\n     * @return {?}\n     */\n    MdbTablePaginationComponent.prototype.checkIfNextShouldBeDisabled = function () {\n        if (this.searchDataSource && (this.lastVisibleItemIndex === this.searchDataSource.length)) {\n            return true;\n        }\n        if (this.activePageNumber >= this.calculateHowManyPagesShouldBe()) {\n            return true;\n        }\n        if (this.nextShouldBeDisabled) {\n            return this.nextShouldBeDisabled;\n        }\n    };\n    /**\n     * @return {?}\n     */\n    MdbTablePaginationComponent.prototype.checkIfPreviousShouldBeDisabled = function () {\n        if (this.activePageNumber === 1) {\n            return true;\n        }\n    };\n    return MdbTablePaginationComponent;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\nvar TableModule = /*@__PURE__*/ (function () {\n    function TableModule() {\n    }\n    return TableModule;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\nvar MDBBadgeComponent = /*@__PURE__*/ (function () {\n    /**\n     * @param {?} _el\n     * @param {?} _renderer\n     */\n    function MDBBadgeComponent(_el, _renderer) {\n        this._el = _el;\n        this._renderer = _renderer;\n    }\n    /**\n     * @return {?}\n     */\n    MDBBadgeComponent.prototype.ngOnInit = function () {\n        var _this = this;\n        this._renderer.addClass(this._el.nativeElement, 'badge');\n        if (this.color) {\n            /** @type {?} */\n            var customClassArr = this.color.split(' ');\n            customClassArr.forEach(function (el) {\n                _this._renderer.addClass(_this._el.nativeElement, el);\n            });\n        }\n    };\n    return MDBBadgeComponent;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\nvar BadgeModule = /*@__PURE__*/ (function () {\n    function BadgeModule() {\n    }\n    return BadgeModule;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\nvar MdbBreadcrumbComponent = /*@__PURE__*/ (function () {\n    function MdbBreadcrumbComponent() {\n    }\n    return MdbBreadcrumbComponent;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\nvar MdbBreadcrumbItemComponent = /*@__PURE__*/ (function () {\n    /**\n     * @param {?} _el\n     * @param {?} _renderer\n     */\n    function MdbBreadcrumbItemComponent(_el, _renderer) {\n        this._el = _el;\n        this._renderer = _renderer;\n    }\n    /**\n     * @return {?}\n     */\n    MdbBreadcrumbItemComponent.prototype.ngOnInit = function () {\n        this._renderer.addClass(this._el.nativeElement, 'breadcrumb-item');\n    };\n    return MdbBreadcrumbItemComponent;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\nvar BreadcrumbModule = /*@__PURE__*/ (function () {\n    function BreadcrumbModule() {\n    }\n    return BreadcrumbModule;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/** @type {?} */\nvar MODULES = [\n    ButtonsModule,\n    CardsFreeModule,\n    RippleModule,\n    WavesModule,\n    InputsModule,\n    NavbarModule,\n    DropdownModule,\n    CarouselModule,\n    ChartsModule,\n    CollapseModule,\n    ModalModule,\n    TooltipModule,\n    PopoverModule,\n    IconsModule,\n    CheckboxModule,\n    TableModule,\n    BadgeModule,\n    BreadcrumbModule\n];\nvar MDBRootModule = /*@__PURE__*/ (function () {\n    function MDBRootModule() {\n    }\n    return MDBRootModule;\n}());\nvar MDBBootstrapModule = /*@__PURE__*/ (function () {\n    function MDBBootstrapModule() {\n    }\n    /**\n     * @return {?}\n     */\n    MDBBootstrapModule.forRoot = function () {\n        return { ngModule: MDBRootModule };\n    };\n    return MDBBootstrapModule;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\nexport { MdbBreadcrumbComponent, MdbBreadcrumbItemComponent, BreadcrumbModule, MDBBadgeComponent, BadgeModule, MdbTablePaginationComponent, MdbTableRowDirective, MdbTableScrollDirective, MdbTableSortDirective, MdbTableDirective, MdbTableService, ButtonsModule, ButtonRadioDirective, ButtonCheckboxDirective, MdbBtnDirective, CHECKBOX_VALUE_ACCESSOR, CheckboxComponent, CheckboxModule, CardsFreeModule, MdbCardComponent, MdbCardBodyComponent, MdbCardImageComponent, MdbCardTextComponent, MdbCardTitleComponent, MdbCardFooterComponent, MdbCardHeaderComponent, RippleModule, RippleDirective, WavesModule, WavesDirective, InputsModule, MdbInputDirective, NavbarModule, BsDropdownConfig, BsDropdownContainerComponent, BsDropdownDirective, BsDropdownMenuDirective, DropdownModule, BsDropdownState, BsDropdownToggleDirective, CarouselComponent, CarouselConfig, CarouselModule, ChartsModule, BaseChartDirective, CollapseComponent, CollapseModule, ModalBackdropComponent, ModalBackdropOptions, ModalDirective, ModalModule, ModalOptions, MDBModalService, ModalContainerComponent, MDBModalRef, TooltipConfig, TooltipContainerComponent, TooltipDirective, TooltipModule, PopoverConfig, PopoverContainerComponent, PopoverModule, PopoverDirective, IconsModule, MdbIconComponent, MDBRootModule, MDBBootstrapModule, CHECKBOX_CONTROL_VALUE_ACCESSOR as c1, RADIO_CONTROL_VALUE_ACCESSOR as b1, SlideComponent as h1, CHECKBOX_VALUE_ACCESSOR as d1, CheckboxComponent as e1, EqualValidatorDirective as f1, LinksComponent as j1, LogoComponent as k1, NavbarComponent as g1, NavbarService as i1, NavlinksComponent as l1, TableModule as a1, ComponentLoaderFactory as m1, OnChange as o1, PositioningService as n1 };\n//# sourceMappingURL=angular-bootstrap-md.es5.js.map\n",null]}